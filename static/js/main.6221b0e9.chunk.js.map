{"version":3,"sources":["App.js","serviceWorkerRegistration.js","reportWebVitals.js","index.js","helpers/RequestsMakers.js","helpers/BackupHelper.js","helpers/DownloadHelper.js","helpers/DashboardPacker.js","helpers/NotesManupulation.js","helpers/DragManager.js","helpers/NoteDeleter.js","helpers/NoteMerger.js","components/Dashboard.js","helpers/DashboardUtils.js","helpers/Messages.js"],"names":["SCOPE","discoveryUrl","App","state","googleAuth","currentUser","localStorage","getItem","loaded","driveFolderId","onlineState","window","navigator","onLine","initScript","a","viewport","document","querySelector","setAttribute","content","innerHeight","addEventListener","setState","loadGAPI","script","createElement","onload","handleClientLoad","src","body","appendChild","console","log","initClient","gapi","client","init","then","auth2","getAuthInstance","isSignedIn","listen","updateSigninStatus","setSigninStatus","e","signInFunction","signIn","signOutFunction","signOut","user","get","hasGrantedScopes","setItem","getBasicProfile","getName","load","this","Dashboard","GAPIloaded","Component","isLocalhost","Boolean","location","hostname","match","registerValidSW","swUrl","config","serviceWorker","register","registration","onupdatefound","installingWorker","installing","onstatechange","controller","onUpdate","onSuccess","catch","error","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","getElementById","URL","process","href","origin","fetch","headers","response","contentType","status","indexOf","ready","unregister","reload","checkValidServiceWorker","serviceWorkerRegistration","getMediaUpdateRequest","note","id","request","path","method","params","uploadType","text","getMetadata","description","JSON","stringify","preview","branches","roots","thread","collection","pinned","color","colorPreview","attachedImg","appProperties","version","getMetaUpdateRequest","createNoteFile","metadata","mimeType","name","fields","parents","shareDriveFolderId","drive","files","create","resource","fileExistenceCheck","list","q","getMediaRequestById","fileId","alt","errorCatcher","counter","targetFunction","args","result","code","setTimeout","updateNoteFile","removeNoteFile","setNotesUpdating","prev","backupNote","metaOrMedia","parseInt","noteCopy","createThumbnail","driveBackupAuthorised","db","notes","update","put","sendUpdateRequest","key","updatesCounter","dbNote","_","require","updateConfigLoop","newDashboard","notesOrder","notesEverDeleted","shareConfigFile","mediaOrMeta","resp","length","requestFunction","updateConfigFile","checkedAgainstDrive","orderOnDrive","parse","isEmpty","xor","Set","deletedOnDrive","removeFromDeletionTracker","deletedNotes","setDeletedNotes","deletedNoteIdx","findIndex","newDeletedNotes","removeElementAt","delete","exportThreadGivenProps","dashboard","bulkGet","selectedNoteId","wholeNotes","selectedThreadText","map","htmlText","exportBeginDelimiter","reduce","accumulator","currentValue","newNoteDelimiter","pri","contentWindow","open","write","close","focus","print","checkDriveFolder","setDriveFolderId","newResp","callSetConfig","notesOnDrive","packDashboard","forceFlag","configFound","mediaResp","notesKeys","keys","filteredNotesKeys","filter","includes","skipUpdatingDrive","deletedNote","index","find","openedCollectionId","openedWorkspaceId","workspaceIds","setConfigFromDrive","updateDriveNotes","getNote","metaResp","currIdx","newNote","set","finishedProcesses","nextPageToken","getNotesPage","targetPageToken","pageToken","i","noteFile","noteId","driveNoteVersion","mightNeedUpdate","setNotesPageFromResp","sampleVersion","removedNoteId","size","getSearchFromProps","searchProps","newSearch","insertingNote","removingIdxs","replace","toLowerCase","searchText","colorFilter","collectionFilter","threadFilter","copyNote","push","errorAlert","removeFromSequence","alert","search","getWorkspace","newWorkspace","flatMap","reportAndAdd","workspace","getLinksFromProps","rootsOrBranches","selectedNote","links","sequence","idx","message","addToWorkspace","element","position","addElementAt","addToBranches","noteFrom","noteToAdd","notAlreadyInBranches","notChildOfItself","branchesWithinLimit","LINKSLIMIT","notAlreadyInRoots","rootsWithinLimits","removeFromBranches","noteToDel","n","getCaption","targetIdx","linkThreadNotes","openInWorkspace","workspaceMode","threadOrCollection","closeAndSaveWorkspace","leaveOpen","confirm","targetNote","anyChangesFlag","arraysEqual","noteSelector","noteToSelect","mergeMode","setMergeMode","setDashboard","getLinks","mergeNotes","mergeBothCardsOccupied","dragManager","setThreadOrCollection","destination","alertMergeMode","source","droppableId","targetId","WORKSPACELIMIT","workspaceLimitReached","targetNoteId","alreadyIn","wrapWorkspace","sourceNote","moveNoteInsideArea","noteToRem","noteDeleter","removingId","noteToRemove","checkConflicts","removingIndex","deleteConflictAlert","presenceCheck","forceRemove","noteMerger","noteA","noteB","deleteNote","newBranches","newRoots","newCollection","newThread","mergeLinksLimit","mergeWorkspaceLimit","dbNoteA","dbNoteB","newText","TEXTLIMIT","mergeTextLimit","noteC","setPreview","katex","NoteEditor","React","lazy","Settings","NotesPage","PREVIEWLIMIT","Dexie","stores","useState","Map","setSearchProps","setRootsOrBranches","currentPage","setCurrentPage","darkMode","setDarkMode","notesUpdating","useEffect","toArray","forEach","darkModeStored","getSearch","synchNotes","getAllNotes","backup","addNote","getNewNote","collectionNote","updateNote","newSelectedNote","action","moveToEndFlag","openOccurrences","moveToTheEnd","handleOnDragEnd","threadOrCollectionManage","cleanWorkspace","selectNote","closeAndSave","exportThread","openEditor","closeCollection","performUpdate","fallback","suspenseLoader","threadCollectionSwap","threadCollectionFlag","collectionToThread","title","style","height","width","border","loadedUser","truncate","slice","area","originalIndex","targetIndex","newArea","string","newPreview","split","substr","checkingId","cumulativeClause","ui_id","nanoid","imgStart","imgEnd","substring","img","exec","isFirst","default","ellipsis","justifyContent","display","type","marginTop","array1","array2","areDifferent","charLimit","mergeModeOn","driveNotConnected"],"mappings":"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","file":"static/js/main.6221b0e9.chunk.js","sourcesContent":["import React, { Component } from 'react';\nimport Dashboard from \"./components/Dashboard\";\n\nvar SCOPE = 'https://www.googleapis.com/auth/drive.file';\nvar discoveryUrl = 'https://www.googleapis.com/discovery/v1/apis/drive/v3/rest';\n\nexport default class App extends Component {\n\n  state = {\n    googleAuth: '',\n    currentUser: localStorage.getItem('currentUser'),\n    loaded: false,\n    driveFolderId:'',\n    onlineState: window.navigator.onLine\n  }\n\n  componentDidMount(){\n   this.initScript()\n  }\n\n  initScript = async () => {\n    // Load authentication script and get Drive API ready\n    var viewport = document.querySelector(\"meta[name=viewport]\");\n    viewport.setAttribute(\n      \"content\", \n      viewport.content + \n      \", height=\" + window.innerHeight + \n      ', user-scalable=no'\n    )\n\n    window.addEventListener('online', () => this.setState({onlineState: true}));\n    window.addEventListener('offline', () => this.setState({onlineState: false}));\n    if(this.state.onlineState){\n      this.loadGAPI()\n    }\n  }\n\n  loadGAPI = async () => {\n    var script = document.createElement('script');\n    script.onload=this.handleClientLoad;\n    script.src=\"https://apis.google.com/js/api.js\";\n    document.body.appendChild(script);\n    console.log('loadingGAPI')\n  }\n\n  componentDidUpdate(){\n    if(this.state.onlineState && !this.state.loaded){\n      this.loadGAPI()\n    }\n  }\n\n  // access is restricted\n  initClient = async () => {\n    try{\n      window.gapi.client.init({\n          'apiKey': \"AIzaSyDmfaKWGbmsMVLYu1nu83egzWI30vgyD-0\",\n          'clientId': \"455375017729-n44ea0ohjt7hb6jpi5ks56ej89cppv93.apps.googleusercontent.com\",\n          'scope': SCOPE,\n          'discoveryDocs': [discoveryUrl]\n        }).then(() => {\n          this.setState({\n            googleAuth: window.gapi.auth2.getAuthInstance(),\n            loaded: true\n          })\n          this.state.googleAuth.isSignedIn.listen(this.updateSigninStatus);  \n          this.state.googleAuth.then(this.setSigninStatus());\n      });\n    }catch(e){\n      console.log(e);\n    }\n\n    // Add event listeners only after script is loaded\n  }\n\n  signInFunction = () => {\n    this.state.googleAuth.signIn()\n  }\n\n  signOutFunction = () => {\n    this.state.googleAuth.signOut()\n  }\n\n  updateSigninStatus = () => {\n    this.setSigninStatus();\n  }\n\n  setSigninStatus = () => {\n    var user = this.state.googleAuth.currentUser.get();\n    if (!user.isSignedIn()){\n      localStorage.setItem('currentUser', null);\n    }\n    else{\n      var isAuthorized = user.hasGrantedScopes(SCOPE);\n      if(isAuthorized){\n        localStorage.setItem('currentUser', user.getBasicProfile().getName());\n      } \n    }\n    this.setState({currentUser : localStorage.getItem('currentUser')});\n  }\n\n  handleClientLoad=()=>{\n    window.gapi.load('client:auth2', this.initClient);\n  }\n\n  render() {\n\n    console.log(localStorage.getItem('currentPage'));\n\n    console.log((localStorage.getItem('currentUser')));\n\n    const currentUser = this.state.currentUser!==null && this.state.currentUser!=='null'\n    return <Dashboard \n      signInFunction={this.signInFunction} \n      signOutFunction={this.signOutFunction} \n      GAPIloaded={this.state.loaded && this.state.onlineState} \n      currentUser={currentUser}\n      />\n  }\n}","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://cra.link/PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(/^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/)\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://cra.link/PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://cra.link/PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log('No internet connection found. App is running in offline mode.');\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n","const reportWebVitals = (onPerfEntry) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorkerRegistration from './serviceWorkerRegistration';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <App />,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://cra.link/PWA\nserviceWorkerRegistration.register();\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n","/*\nAuthor: Nicola Mendini\nDate: 13/09/2021\nThinkyThreads Project\nRequestMakers functions\nGenerally they create request that are then executed by other\nfunctions, define the requests bodies\n*/\n\nimport { shareDriveFolderId, db , driveBackupAuthorised} from \"../components/Dashboard\"\nimport { createThumbnail } from \"./DashboardUtils\"\nimport { updateNoteFile, removeNoteFile } from \"./BackupHelper\"\n\n// Function to create a Media Update request\n// it changes the content of the file to be the text of the note\n// as shown in the body field of the request\nexport function getMediaUpdateRequest(note, id){ \n    return window.gapi.client.request({\n        path: 'upload/drive/v3/files/' + id,\n        method: 'PATCH',\n        params: {\n            uploadType: 'media'\n        },\n        body: note.text\n    })\n}\n\n// Function to convert a note into a metadata object\n// that then gets attached to a file in a request\nexport function getMetadata(note){\n    return {\n        description : JSON.stringify({\n            id: note.id,\n            preview: note.preview,\n            branches: note.branches,\n            roots: note.roots,\n            thread: note.thread,\n            collection: note.collection,\n            pinned: note.pinned,\n            color: note.color,\n            colorPreview: note.colorPreview,\n            attachedImg: note.attachedImg,\n        }),\n        appProperties: {\n            version: note.version\n        }\n    }\n}\n\n// Request to update the metadata only, \n// similar to the Media one except this passes the metadata\n// object in the body\nexport function getMetaUpdateRequest(note, id){\n\n    return window.gapi.client.request({\n        path: 'drive/v3/files/' + id,\n        method: 'PATCH',\n        body: getMetadata(note)\n    })\n}\n\n// Returns a request to create a file starting from a note\n// the file is created inside the folder given by shareDriveFolderId\nexport function createNoteFile(note, metadata){\n    if(!metadata){metadata = getMetadata(note)}\n    metadata.mimeType = 'application/json'\n    metadata.name = note.id\n    metadata.fields = 'id'\n    metadata.parents = [shareDriveFolderId]\n    return window.gapi.client.drive.files.create({\n            resource: metadata\n        }\n    )\n}\n\n// Returns a request to check if a file associated to a given note already exists \n// once the request is executed the response shows the search results\nexport function fileExistenceCheck(note){\n    return window.gapi.client.drive.files.list({\n        q:\"name='\"+ note.id +\n        \"' and mimeType='application/json' and trashed=false and '\"+ \n        shareDriveFolderId + \"' in parents\",\n    })\n}\n\n// Returns a request to get a notes media given the id of the note file directly\nexport function getMediaRequestById(fileId){\n    return window.gapi.client.drive.files.get({\n        mimeType: 'application/json',\n        fileId: fileId,\n        alt: 'media'\n    })\n}\n\n// Error catcher functions used in all the functions that involve Google Drive API\n// If an error occurs, call the function again with the same arguments up to 4 times\nexport function errorCatcher(error, counter, targetFunction, ...args){\n    console.error(error)\n    counter+=1\n    if((error.result && error.result.error.code===-1 && counter<2) || counter<4){\n        setTimeout(() => {\n            targetFunction(...args, counter)\n        }, 1000);\n    }\n    else{\n\n        // If the function to call again is update and max calls have been attempted, \n        //subtract one from the counter because the backup will be interrupted\n        if(targetFunction===updateNoteFile || targetFunction===removeNoteFile){\n            const setNotesUpdating=args[2]\n            setNotesUpdating((prev) => prev-1)\n        }\n    }\n}\n\n// Function called to backup a note both locally and on drive\n// takes the note, a metaOrMedia flag that controls the kind of update\n// and the setNotesUpdating Function used to keep track of the active updates\nexport function backupNote(note, metaOrMedia, setNotesUpdating){\n\n    // Increment the notes version and make a copy of it that will be backed up\n    note.version = parseInt(note.version) + 1\n    const noteCopy = {...note}\n\n    // If the note contains an image, backup the original text and reset the \n    // displaying text to the image itself. Exploits a trick to efficiently \n    // show an image preview when the note contains one at the beginning\n    createThumbnail(note)\n\n    // Perform the backup on drive as well if it is possible\n    if(driveBackupAuthorised){\n        setNotesUpdating((prev) => prev+1)\n        updateNoteFile(noteCopy, metaOrMedia, setNotesUpdating)\n    }\n\n    // Perform the backup locally on indexedDB and store the text only when it is needed\n    if(metaOrMedia==='meta'){\n        delete noteCopy.text\n        db.notes.update(noteCopy.id, noteCopy)\n    }\n    else{\n        db.notes.put(noteCopy)\n    }\n}\n\n// Returns an update request for a given note\n// It is passed an updatesCounter to delay the execution of the update\n// in the case that already many updates are occuring\n// In other words it ensured that the requests are well separated in time\nexport function sendUpdateRequest(key, updatesCounter, setNotesUpdating){\n    db.notes.get(key).then((dbNote) => \n        setTimeout(() => {\n            setNotesUpdating((prev) => prev+1)\n            updateNoteFile(dbNote, 'both', setNotesUpdating)\n        }, (200 * updatesCounter))\n    )\n}","/*\nAuthor: Nicola Mendini\nDate: 13/09/2021\nThinkyThreads Project\nBackupHelper functions\nFunction to backup notes on drive\n*/\n\nimport { db, shareConfigFile, shareDriveFolderId } from \"../components/Dashboard\"\nimport { removeElementAt } from \"./DashboardUtils\"\nimport { exportBeginDelimiter, newNoteDelimiter } from \"./Messages\"\nimport { \n    getMediaUpdateRequest, \n    getMetaUpdateRequest, \n    errorCatcher, \n    fileExistenceCheck, \n    createNoteFile, \n    getMediaRequestById\n} from \"./RequestsMakers\"\nconst _ = require('lodash')\n\n// Try to update the config file on drive by sendin the request\nexport function updateConfigLoop(newDashboard, counter){\n\n    // The config only includes the notesOrder\n    if(!counter){counter=0}\n    const configBody = JSON.stringify({\n        notesOrder: newDashboard.notesOrder,\n        notesEverDeleted: newDashboard.notesEverDeleted\n    })\n        getMediaUpdateRequest({text: configBody}, shareConfigFile.id).then(\n    ).catch((error) => errorCatcher(error, counter, updateConfigLoop, newDashboard))\n}\n\n// Function to update a note file on drive\nexport function updateNoteFile(note, mediaOrMeta, setNotesUpdating, counter){\n\n    // Initialise the counter of calls\n    if(!counter){counter=0}\n\n    // Try to access the file\n    fileExistenceCheck(note).then((resp)=>{\n\n        // If it does not exist\n        if(!resp.result.files.length){\n\n            // create it by calling this function again in media mode\n            createNoteFile(note).then(() => {\n\n                if(mediaOrMeta!=='meta'){\n                    updateNoteFile(note, 'media', setNotesUpdating)\n                }\n                else{\n                    setNotesUpdating((prev) => prev-1)\n                }\n            }).catch((error) => \n                errorCatcher(\n                    error, \n                    counter, \n                    updateNoteFile, \n                    note, \n                    mediaOrMeta, \n                    setNotesUpdating\n                )\n            )\n        }\n\n        // if the file exists, get its id and initialise a placeholder for the \n        // request function that is needed\n        else{\n            const fileId = resp.result.files[0].id\n            var requestFunction = null\n\n            // if the request is media or both, it is a media request\n            if(mediaOrMeta==='media' || mediaOrMeta==='both'){\n                requestFunction = getMediaUpdateRequest\n            }\n\n            // otherwise just ask for a meta request\n            else if(mediaOrMeta==='meta'){\n                requestFunction = getMetaUpdateRequest\n            }\n            requestFunction(note, fileId).then(function(resp) {\n                // if the request is both, update meta as well after updating media\n                if(mediaOrMeta==='both'){\n                    updateNoteFile(note, 'meta', setNotesUpdating)\n                }\n\n                // otherwise update finished and decrease the active updates counter\n                else{\n                    console.log('updated')\n                    setNotesUpdating((prev) => prev-1)\n                }\n\n            }).catch((error) => \n                errorCatcher(\n                    error, \n                    counter, \n                    updateNoteFile, \n                    note, \n                    mediaOrMeta, \n                    setNotesUpdating\n                )\n            )\n        }\n    }).catch((error) =>     \n        errorCatcher(\n            error, \n            counter,    \n            updateNoteFile, \n            note, \n            mediaOrMeta, \n            setNotesUpdating\n        )\n    )\n}\n\n// function to create an empty config file\nexport function createConfigFile(newDashboard, counter){\n    const configMetadata = {}\n    createNoteFile({id: '___config'}, configMetadata).then((newResp) => {\n        shareConfigFile.id = newResp.result.id\n        updateConfigFile(newDashboard)\n    }).catch((error) => errorCatcher(error, counter, createConfigFile, newDashboard))\n}\n\n// Function to update the config file on drive\nexport function updateConfigFile(newDashboard, counter){\n\n    if(newDashboard.checkedAgainstDrive){\n        console.log('updateconfig')\n        if(!counter){counter=0}\n\n        getMediaRequestById(shareConfigFile.id).then((resp)=>{\n\n            // before touching the file on drive make sure that there haven't been any updates\n            const orderOnDrive = JSON.parse(resp.body).notesOrder\n            if(!_.isEmpty(_.xor(newDashboard.notesOrder, orderOnDrive))){\n                newDashboard.notesOrder = [...new Set([...newDashboard.notesOrder, ...orderOnDrive])]\n                window.localStorage.setItem('notes-order', newDashboard.notesOrder)\n            }\n\n            const deletedOnDrive = JSON.parse(resp.body).notesEverDeleted\n            if(!_.isEmpty(_.xor(newDashboard.notesEverDeleted, deletedOnDrive))){\n                newDashboard.notesEverDeleted = [...new Set([...newDashboard.notesEverDeleted, ...deletedOnDrive])]\n                window.localStorage.setItem('notes-ever-deleted', newDashboard.notesEverDeleted)\n            }\n\n            // if file found and notesOrder okay, proceed\n            updateConfigLoop(newDashboard)\n\n        }).catch((error) => error.status===404 ? console.log(true) : errorCatcher(error, counter, updateConfigFile, newDashboard))\n    }\n\n    // if the getAllNotes is not done yet config cannot update\n    else{\n        console.log('blocked')\n    }\n}\n\n// Function to remove a file from the deletedNotes tracker\nexport function removeFromDeletionTracker(note, deletedNotes, setDeletedNotes){\n    console.log('deleted')\n\n    // find the index of the note to delete\n    const deletedNoteIdx = deletedNotes.findIndex(id => id===note.id)\n    if(deletedNoteIdx!==-1){\n        const newDeletedNotes = removeElementAt(deletedNotes, deletedNoteIdx)\n        setDeletedNotes(newDeletedNotes)\n\n        // backup the deleted notes array locally\n        window.localStorage.setItem('deleted-notes', JSON.stringify(newDeletedNotes))\n    }\n}\n\n// Removes a notes file from drive\nexport function removeNoteFile(note, deletedNotes, setDeletedNotes, setNotesUpdating, counter){\n    if(!counter){counter=0}\n\n    // if it exists, try to remove\n    fileExistenceCheck(note).then(function(resp){\n        if(resp.result.files.length){\n            window.gapi.client.drive.files.delete({\n                'fileId': resp.result.files[0].id\n            }).then(function() { \n\n                // if successful, delete from tracker as well\n                removeFromDeletionTracker(note, deletedNotes, setDeletedNotes)\n                setNotesUpdating((prev) => prev-1)\n\n            }).catch((error) => \n                errorCatcher(\n                    error, \n                    counter, \n                    removeNoteFile, \n                    note, \n                    deletedNotes, \n                    setDeletedNotes, \n                    setNotesUpdating\n                )\n            )\n        }\n\n        // if it does not exist, remove from tracker and that is it\n        else{\n            removeFromDeletionTracker(note, deletedNotes, setDeletedNotes)\n        }\n    }).catch((error) => \n        errorCatcher(\n            error, \n            counter, \n            removeNoteFile, \n            note, \n            deletedNotes, \n            setDeletedNotes, \n            setNotesUpdating\n        )\n    )\n    \n}\n\n// Function to export a thread as a PDF or print\nexport function exportThreadGivenProps(dashboard){\n\n    // get all notes from DB that belong to thread and extract text\n    db.notes.bulkGet(dashboard.notes.get(dashboard.selectedNoteId).thread).then((wholeNotes) => {\n        const selectedThreadText = wholeNotes.map((note) => note.text);\n\n        // concatenate all of them with delimiters \n        const reducer = (accumulator, currentValue) => accumulator + \n             newNoteDelimiter\n            + currentValue;\n\n        // add the start delimiter\n        const htmlText = \n            exportBeginDelimiter + \n            selectedThreadText.reduce(reducer);\n\n        // print it\n        var pri = document.getElementById(\"ifmcontentstoprint\").contentWindow;\n        pri.document.open();\n        pri.document.write(htmlText);\n        pri.document.close();\n        pri.focus();\n        pri.print();\n    })\n}\n\n// Check for the existence of the thinkythreads folder\nexport function checkDriveFolder(setDriveFolderId, counter){\n\n    console.log('checkingfolder')\n    if(!counter){counter=0}\n\n    window.gapi.client.drive.files.list({\n      q:\"name='thinkythreads-data' \" +\n      \"and mimeType='application/vnd.google-apps.folder' \" +\n      \"and trashed=false\",\n    }).then((resp)=>{\n\n        // if it does not exist, create it\n        if(!resp.result.files.length){\n            var fileMetadata = {\n            'name': 'thinkythreads-data',\n            'mimeType': 'application/vnd.google-apps.folder'\n            };\n            window.gapi.client.drive.files.create({\n            resource: fileMetadata,\n            fields: 'id'\n            }).then((newResp) => {\n                    \n                // after creation, set the driveFolder state to the new folder\n                setDriveFolderId(newResp.result.id)\n\n            }).catch((error) => errorCatcher(error, counter, checkDriveFolder, setDriveFolderId))\n        }\n        else{\n            if(resp.result.files[0].id!==shareDriveFolderId){\n                setDriveFolderId(resp.result.files[0].id)\n            }\n        }\n    }).catch((error) => errorCatcher(error, counter, checkDriveFolder, setDriveFolderId))\n}","/*\nAuthor: Nicola Mendini\nDate: 13/09/2021\nThinkyThreads Project\nDownloadHelper functions\nContains functions that help the retrieval of notes on GDrive\n*/\n\nimport { shareDriveFolderId, db, shareConfigFile } from \"../components/Dashboard\";\nimport { createThumbnail, removeElementAt } from \"./DashboardUtils\";\nimport { getMediaRequestById, errorCatcher, sendUpdateRequest } from \"./RequestsMakers\";\nimport { updateConfigFile, removeNoteFile } from \"./BackupHelper\";\nconst _ = require('lodash')\n\n// Function to create a new note from a drive file response\n// takes both the metaResponse and the mediaResponse\n// currIdx defines the index of the current file on drive\n// notesOnDrive stores all the notes that have been found on drive\nexport function setNoteFromResp(\n    newDashboard, \n    notesOnDrive, \n    metaResp, \n    mediaResp, \n    currIdx, \n    deletedNotes, \n    setDeletedNotes, \n    setNotesUpdating, \n    packDashboard\n){\n\n    // create the note object and add the text field and version\n    const newNote = JSON.parse(metaResp.result.files[currIdx].description)\n    newNote.text = mediaResp.body;\n    newNote.version = parseInt(metaResp.result.files[currIdx].appProperties.version)\n\n    // add it to the dashboard and backup locally\n    newDashboard.notes.set(newNote.id, newNote);\n    db.notes.put(newNote).then(\n\n        // check if it needs a thumbnail and create it\n        createThumbnail(newNote)\n    )\n    notesOnDrive.finishedProcesses += 1\n    setNotesUpdating((prev) => prev-1)\n\n    // if all the notes on drive have been processed\n    if(notesOnDrive.finishedProcesses === metaResp.result.files.length){\n\n        // if there is a next page of files on drive, download the files of the next page\n        if(metaResp.result.nextPageToken){\n            getNotesPage(\n                newDashboard, \n                notesOnDrive, \n                deletedNotes, \n                setDeletedNotes, \n                setNotesUpdating, \n                packDashboard, \n                metaResp.result.nextPageToken\n            )\n        }\n\n        // otherwise if all the files have been processed set the config file\n        else{\n            callSetConfig(\n                notesOnDrive, \n                newDashboard, \n                packDashboard, \n                deletedNotes,\n                setDeletedNotes,\n                setNotesUpdating,\n                true\n            )\n        }\n    }\n}\n\n// function used to decide what config file prevails, either that on drive or local\nexport function callSetConfig(\n    notesOnDrive, \n    newDashboard, \n    packDashboard, \n    deletedNotes,\n    setDeletedNotes,\n    setNotesUpdating, \n    forceFlag\n){\n    // if a config file has been found and any note has been modified by data on drive,\n    // overwrite the local configuration with the online one\n    if(notesOnDrive.configFound){\n        getMediaRequestById(notesOnDrive.configFound).then(\n            (mediaResp) => {\n                // if the config is not empty\n                if(mediaResp.body!==''){\n                    \n                    // retrieve the notes order and check that it covers every single note stored\n                    // must make sure that notes are not left out\n                    const config = JSON.parse(mediaResp.body)\n                    const notesKeys = [...newDashboard.notes.keys()]\n                    const filteredNotesKeys = notesKeys.filter(\n                        (id) => !config.notesEverDeleted.includes(id)\n                    )\n\n                    // forceFlag means that the drive notes were already used to replace local notes\n                    // and therefore they get to update the config anyways\n                    // otherwise if all the drive notes were not used so far,\n                    // check if at least they are used for removing notes that the user deleted\n                    // if no, then update them because they might be outdated\n                    if(forceFlag || notesKeys.length!==filteredNotesKeys.length){\n                        if(setConfigFromDrive(newDashboard, config, packDashboard)){\n                            updateDriveNotes(\n                                newDashboard, \n                                notesOnDrive, \n                                deletedNotes, \n                                setDeletedNotes, \n                                setNotesUpdating, \n                                packDashboard\n                            )\n                        }\n                    }\n\n                    else{\n                        updateDriveNotes(\n                            newDashboard, \n                            notesOnDrive, \n                            deletedNotes, \n                            setDeletedNotes, \n                            setNotesUpdating, \n                            packDashboard\n                        )\n                    }\n                }\n                else{\n                    updateDriveNotes(\n                        newDashboard, \n                        notesOnDrive, \n                        deletedNotes, \n                        setDeletedNotes, \n                        setNotesUpdating, \n                        packDashboard\n                    )\n                }\n            }\n        )\n    }\n\n    // otherwise initialise a new random order for the notes\n    // this might happen if the config file is deleted\n    else if (forceFlag){\n        newDashboard.notesOrder = [...new Set([newDashboard.notesOrder, ...newDashboard.notes.keys()])]\n        newDashboard.checkedAgainstDrive = true\n        updateConfigFile(newDashboard)\n        packDashboard(newDashboard)\n    }\n\n    // if no drive notes have been used yet and no config file was found\n    else{\n        updateDriveNotes(\n            newDashboard, \n            notesOnDrive, \n            deletedNotes, \n            setDeletedNotes, \n            setNotesUpdating, \n            packDashboard\n        )\n    }\n}\n\n// get a single notes media given the metaResponse and the currIdx\nexport function getNote(\n    newDashboard, \n    notesOnDrive, \n    metaResp, \n    currIdx, \n    deletedNotes, \n    setDeletedNotes, \n    setNotesUpdating, \n    packDashboard, \n    counter\n){\n    if(!counter){counter=0}\n    getMediaRequestById(metaResp.result.files[currIdx].id).then((mediaResp) =>\n\n        // once the media is downloaded, create an object from it and add it to dashboard\n        setNoteFromResp(\n            newDashboard, \n            notesOnDrive, \n            metaResp, \n            mediaResp, \n            currIdx, \n            deletedNotes, \n            setDeletedNotes, \n            setNotesUpdating, \n            packDashboard\n        )\n\n    ).catch((error) => errorCatcher(\n        error, \n        counter, \n        getNote, \n        newDashboard, \n        notesOnDrive, \n        metaResp, \n        currIdx,\n        deletedNotes,\n        setDeletedNotes,\n        setNotesUpdating,\n        packDashboard\n    ))\n}\n\n// download a whole page of files metadatas \n// so that later you can access their content individually\nexport function setNotesPageFromResp(\n    newDashboard, \n    notesOnDrive, \n    metaResp, \n    deletedNotes, \n    setDeletedNotes, \n    setNotesUpdating, \n    packDashboard\n){\n\n    // keep count of the files processed\n    notesOnDrive.finishedProcesses = 0\n\n    // for all the files on drive\n    for(let i=0; i<metaResp.result.files.length; i++){\n\n        // placeholder for the noteFile object and for the note id\n        const noteFile = metaResp.result.files[i]\n        const noteId = noteFile.name\n\n        // if config file encountered, store the id of the file and finish the process\n        if(noteId==='___config'){\n            notesOnDrive.configFound = noteFile.id\n            // eslint-disable-next-line\n            shareConfigFile.id = noteFile.id\n            notesOnDrive.finishedProcesses +=1\n        }\n        \n        // else if the file was not a deleted one, add it to notesOnDrive\n        else if(!deletedNotes.includes(noteId)){\n            const driveNoteVersion = parseInt(noteFile.appProperties.version)\n            notesOnDrive.set(\n                noteId, \n                driveNoteVersion\n            )\n\n            // retrieve the note and check that it exists\n            const note = newDashboard.notes.get(noteId)\n            if(!note || driveNoteVersion>note.version){\n            \n                // if not retrieve its media and download it\n                // if even a single file is more updated than its local counterpart,\n                // set the flag mightNeedUpdate to false so that local notes will not \n                // touch the online ones for now\n                notesOnDrive.mightNeedUpdate = false\n                getNote(\n                    newDashboard, \n                    notesOnDrive, \n                    metaResp, \n                    i, \n                    deletedNotes, \n                    setDeletedNotes, \n                    setNotesUpdating, \n                    packDashboard\n                )\n                setNotesUpdating((prev) => prev+1)\n            }\n\n            // if conditions not met, end the process \n            else{\n                notesOnDrive.finishedProcesses +=1\n            }\n        }\n\n        else{\n            notesOnDrive.finishedProcesses +=1\n        }\n    }\n\n    // at the end of a page, if no note file was used to restore local notes\n    if(notesOnDrive.mightNeedUpdate){\n\n        // if there are other pages, try with the next one\n        if(metaResp.result.nextPageToken){\n            getNotesPage(\n                newDashboard, \n                notesOnDrive, \n                deletedNotes, \n                setDeletedNotes, \n                setNotesUpdating, \n                packDashboard, \n                metaResp.result.nextPageToken\n            )\n        }\n\n        // otherwise update the notes on drive because they might be outdated\n        else{\n            callSetConfig(\n                notesOnDrive, \n                newDashboard, \n                packDashboard, \n                deletedNotes,\n                setDeletedNotes,\n                setNotesUpdating\n            )\n        }\n    }\n\n    // if no notes of the last page of drive are used to replace local notes\n    // call the setConfigFromDrive from here rather than from setNoteFromResp\n    else if(\n    !notesOnDrive.mightNeedUpdate && \n    !metaResp.result.nextPageToken && \n    notesOnDrive.finishedProcesses === metaResp.result.files.length\n    ){\n        callSetConfig(\n            notesOnDrive, \n            newDashboard, \n            packDashboard, \n            deletedNotes,\n            setDeletedNotes,\n            setNotesUpdating,\n            true\n        )\n    }\n}\n\n// Function to get the metas of a whole drive page\nexport function getNotesPage(\n    newDashboard, \n    notesOnDrive, \n    deletedNotes, \n    setDeletedNotes, \n    setNotesUpdating, \n    packDashboard, \n    targetPageToken, \n    counter\n){\n\n    if(!counter){counter=0}\n    // list all files that are in that folder\n    window.gapi.client.drive.files.list({\n        fields: 'nextPageToken, files(description, id, name, appProperties)',\n        q:\"mimeType='application/json' and trashed=false and '\" + \n        shareDriveFolderId + \"' in parents\",\n        pageToken: targetPageToken\n\n    }).then((metaResp) => {\n\n        setNotesPageFromResp(\n            newDashboard, \n            notesOnDrive, \n            metaResp, \n            deletedNotes, \n            setDeletedNotes, \n            setNotesUpdating, \n            packDashboard\n        )\n        \n    }).catch((error) => errorCatcher(\n        error, \n        counter, \n        getNotesPage, \n        newDashboard, \n        notesOnDrive, \n        deletedNotes,\n        setDeletedNotes,\n        setNotesUpdating,\n        packDashboard,\n        targetPageToken\n    ))\n}\n\n// Function that starts the recursion, try to restore notes from drive\n// if not, update the notes on drive if needed\nexport function getAllNotes(\n    newDashboard, \n    deletedNotes, \n    setDeletedNotes, \n    setNotesUpdating, \n    packDashboard, \n    counter\n){\n\n    // notesOnDrive keeps track of the backup/restoring process\n    if(!counter){counter=0}\n    const notesOnDrive = new Map()\n    notesOnDrive.configFound = false\n    notesOnDrive.finishedProcesses = 0\n    notesOnDrive.mightNeedUpdate = true\n\n    getNotesPage(\n        newDashboard, \n        notesOnDrive, \n        deletedNotes, \n        setDeletedNotes, \n        setNotesUpdating, \n        packDashboard\n    )\n}\n\n// Sets a config file from the .config on drive\nexport function setConfigFromDrive(newDashboard, config, packDashboard){\n\n    newDashboard.notesEverDeleted = config.notesEverDeleted\n\n    // variable used to check whether there are files locally that drive does not have\n    var skipUpdatingDrive = true\n\n    for(const deletedNote of newDashboard.notesEverDeleted){\n        if(newDashboard.notes.get(deletedNote)){\n\n            // no need to call the note deleter because there will be no dependencies\n            // as all the other local notes have already been updated\n            newDashboard.notes.delete(deletedNote)\n            const index = newDashboard.notesOrder.find(id => id===deletedNote)\n            if(index){\n                newDashboard.notesOrder = removeElementAt(newDashboard.notesOrder, index)\n            }\n        }\n    }\n\n    // make sure you are not removing a note that is employed in the dashboard\n    if(newDashboard.notesEverDeleted.includes(newDashboard.selectedNoteId)){\n        newDashboard.selectedNoteId = null\n    }\n    if(newDashboard.notesEverDeleted.includes(newDashboard.openedCollectionId)){\n        newDashboard.openedCollectionId = null\n    }\n    if(newDashboard.notesEverDeleted.includes(newDashboard.openedWorkspaceId)){\n        newDashboard.openedWorkspaceId = null\n    }\n    newDashboard.workspaceIds = newDashboard.workspaceIds.filter(\n        (id) => !newDashboard.notesEverDeleted.includes(id)\n    )\n\n    // if the config file includes all the notes and therefore is up to date\n    if(_.isEmpty(_.xor([...newDashboard.notes.keys()], config.notesOrder))){\n        newDashboard.notesOrder = config.notesOrder\n    }\n\n    // otherwise just restore some pseudo order with the notes that we have and the previous order\n    else{\n        newDashboard.notesOrder = [...new Set([...newDashboard.notesOrder, ...config.notesOrder])]\n        skipUpdatingDrive=false\n    }   \n\n    // backing up values received from drive\n    window.localStorage.setItem('notes-order', JSON.stringify(newDashboard.notesOrder))\n    window.localStorage.setItem('notes-ever-deleted', JSON.stringify(newDashboard.notesEverDeleted))\n\n    // Tell the dashboard that the restoring is complete and backup the new order\n    newDashboard.checkedAgainstDrive = true\n\n    if(skipUpdatingDrive){\n        packDashboard(newDashboard)\n    }\n    else{\n        return true\n    }\n}\n\n// Update the notes on google drive if they might be outdated\nexport function updateDriveNotes(\n    newDashboard, \n    notesOnDrive, \n    deletedNotes, \n    setDeletedNotes, \n    setNotesUpdating, \n    packDashboard\n){\n    var updatesCounter = 0\n\n    for(const [key, note] of newDashboard.notes){\n\n        const sampleVersion = notesOnDrive.get(key)\n\n        // for each of the notes that need to be updated, send a request\n        if(!sampleVersion || sampleVersion<note.version){\n            \n            updatesCounter+=1\n            sendUpdateRequest(key, updatesCounter, setNotesUpdating)\n        }\n    }\n\n    // For all the notes that have not been removed from drive yet, but they should, \n    // remove them \n    for(const removedNoteId of deletedNotes){\n\n        updatesCounter+=1\n        setTimeout(() => {\n            setNotesUpdating((prev) => prev+1)\n            removeNoteFile({id: removedNoteId}, deletedNotes, setDeletedNotes, setNotesUpdating)\n        }, (200 * updatesCounter))\n    }\n\n    // Once finished update the config file on drive\n    newDashboard.checkedAgainstDrive = true\n    if(updatesCounter || !notesOnDrive.configFound){\n        if(newDashboard.notesOrder.length!==newDashboard.notes.size){\n            newDashboard.notesOrder = [...new Set([...newDashboard.notesOrder, ...[...newDashboard.notes.keys()]])]\n        }\n        updateConfigFile(newDashboard)\n    }\n\n    packDashboard(newDashboard)\n}","/*\nAuthor: Nicola Mendini\nDate: 13/09/2021\nThinkyThreads Project\nDashboardPacker functions\nUpdate the functions based on the new states of the dashboard\n*/\n\nimport { driveBackupAuthorised } from \"../components/Dashboard\"\nimport { updateConfigFile } from \"./BackupHelper\"\nimport { copyNote } from \"./DashboardUtils\"\nimport { backupNote } from \"./RequestsMakers\"\n\n// Change the search as the user is typing\nexport function getSearchFromProps(newDashboard, searchProps){\n\n    // go through all the notes and decide whether each note should be inserted\n    var newSearch = []\n    var insertingNote = []\n    const removingIdxs = []\n    \n    for(let i=0; i<newDashboard.notesOrder.length; i++){\n\n        const key = newDashboard.notesOrder[i]\n        const note = newDashboard.notes.get(key)\n\n        // if the note exists\n        if(note){\n            insertingNote = []\n\n            // if the text matched with the text on the searchBar insert it\n            if(note.preview.replace( /(<([^>]+)>)/ig, '').toLowerCase().includes(searchProps.searchText)){\n\n                insertingNote=[note]\n\n                if(searchProps.colorFilter!=='#ededed' && searchProps.colorFilter!==note.colorPreview){\n                    insertingNote=[]\n                }\n\n                // if the thread filter and the collections filters are on but the note has none, remove it\n                if(insertingNote.length && searchProps.collectionFilter && searchProps.threadFilter){\n                    if(!note.thread.length && !note.collection.length){\n                        insertingNote=[]\n                    }\n                }\n\n                // if the thread filter is on but the note has none, remove it from the insertion\n                else if(insertingNote.length && searchProps.threadFilter){\n                    if(!note.thread.length){\n                        insertingNote=[]\n                    }\n                }\n\n                // if the collection filter is on but the note has none, remove it from the insertion\n                else if(insertingNote.length && searchProps.collectionFilter){\n                    if(!note.collection.length){\n                        insertingNote=[]\n                    }\n                }\n\n                // If a collection is opened add a new constraint\n                if(insertingNote.length && newDashboard.openedCollectionId){\n                    if(!newDashboard.notes.get(newDashboard.openedCollectionId).collection.includes(note.id)){\n                        insertingNote=[]\n                    }\n                }\n\n                // if the note is pinned, put at the beginning, if not, at the end\n                if(insertingNote.length){\n                    if(note.pinned){\n                        newSearch = [copyNote(insertingNote[0]), ...newSearch]\n                    }\n                    else{\n                        newSearch = [...newSearch, copyNote(insertingNote[0])]\n                    }\n                }\n            }\n        }\n        else{\n            removingIdxs.push(i)\n            errorAlert('noteOfSearchNotFoundError!', key, newDashboard)\n        }\n    }\n\n    if(removingIdxs.length){\n        newDashboard.notesOrder = removeFromSequence(removingIdxs, newDashboard.notesOrder)\n        window.localStorage.setItem('notes-order', JSON.stringify(newDashboard.notesOrder))\n        updateConfigFile(newDashboard)\n    }\n\n    if(newDashboard.notesOrder.length && newDashboard.notesOrder.length !== newDashboard.notes.size){\n        newDashboard.notesOrder = [...new Set([newDashboard.notesOrder, ...newDashboard.notes.keys()])]\n        if(driveBackupAuthorised){\n            window.localStorage.setItem('notes-order', JSON.stringify(newDashboard.notesOrder))\n            updateConfigFile(newDashboard)\n        }\n        window.alert(\n            '-------- BETA VERSION ERROR REPORT ------- \\n' + \n        '---- PLEASE SHARE WITH THE DEVELOPER --- \\n' +\n        'along with some info about what you did to get here \\n' +\n        'EMAIL: nicolamendini0@gmail.com \\n' +\n        'THANK YOU!' +\n        '\\n\\nERROR: \\n' + \n        'The order of the notes was lost'\n        )\n    }\n\n    newDashboard.search = newSearch\n    // eslint-disable-next-line\n}\n\n// Function to pack the workspace\nexport function getWorkspace(newDashboard){\n    const removingIdxs = []\n    const newWorkspace = newDashboard.workspaceIds.flatMap(\n        (id, index) => reportAndAdd(\n            newDashboard, \n            id, \n            index, \n            removingIdxs, \n            'noteOfWorkspaceNotFoundError!'\n        )\n    )\n    newDashboard.workspace = newWorkspace\n    if(removingIdxs.length){\n        newDashboard.workspaceIds = removeFromSequence(removingIdxs, newDashboard.workspaceIds)\n\n    }\n} \n\n// Get the notes that are links of the selectedNote based on the direction of links given by rootsOrBranches\nexport function getLinksFromProps(newDashboard, rootsOrBranches, setNotesUpdating){\n        \n    if(newDashboard.selectedNoteId){\n\n        const selectedNote = newDashboard.notes.get(newDashboard.selectedNoteId)\n        const removingIdxs = []\n\n        if(rootsOrBranches){\n            newDashboard.links = selectedNote.roots.flatMap(\n                (id, index) => reportAndAdd(\n                    newDashboard, \n                    id, \n                    index, \n                    removingIdxs, \n                    'noteOfLinksNotFoundError'\n                )   \n            )\n            if(removingIdxs.length){\n                selectedNote.roots = removeFromSequence(removingIdxs, selectedNote.roots)\n                backupNote(selectedNote, 'meta', setNotesUpdating)\n            }\n        }\n        else{\n            newDashboard.links = selectedNote.branches.flatMap(\n                (id, index) => reportAndAdd(\n                    newDashboard, \n                    id, \n                    index, \n                    removingIdxs, \n                    'noteOfLinksNotFoundError'\n                )\n            )\n            if(removingIdxs.length){\n                selectedNote.branches = removeFromSequence(removingIdxs, selectedNote.branches)\n                backupNote(selectedNote, 'meta', setNotesUpdating)\n            }   \n        }\n    }\n    else{\n        newDashboard.links = []\n    }\n}\n\n// Removes several elements from a sequence\n// Used if some ghost ids are present in some sequence\nexport function removeFromSequence(removingIdxs, sequence){\n    return sequence.filter(\n        (e, idx) => !removingIdxs.includes(idx)\n    )\n}\n\n// if the note corresponding to the id exists, return it\n// otherwise show an error report\nexport function reportAndAdd(newDashboard, id, index, removingIdxs, message){\n    const note = newDashboard.notes.get(id)\n\n    if(note){\n        return [copyNote(newDashboard.notes.get(id))]\n    }\n\n    else{\n        removingIdxs.push(index)\n        errorAlert(message, id, newDashboard)\n        return []\n    }\n}\n\nexport function errorAlert(message, id, newDashboard){\n    window.alert(\n        '-------- BETA VERSION ERROR REPORT ------- \\n' + \n        '---- PLEASE SHARE WITH THE DEVELOPER --- \\n' +\n        'along with some info about what you did to get here \\n' +\n        'EMAIL: nicolamendini0@gmail.com \\n' +\n        'THANK YOU!' +\n        '\\n\\nERROR: \\n' + \n        message + \n        '\\n\\nNOTE: \\n' + \n        id + '\\n' +\n        '\\n\\nNOTES-ORDER: \\n' + \n        newDashboard.notesOrder + \n        '\\n\\nLINKS: \\n' + \n        newDashboard.links +\n        '\\n\\nWORKSPACE-IDS: \\n' +\n        newDashboard.workspaceIds\n    )\n}","/*\nAuthor: Nicola Mendini\nDate: 13/09/2021\nThinkyThreads Project\nNotesManipulation functions\nFunction to manipulate and change Note objects\neg: add/remove links or edit threads \n*/\n\nimport { LINKSLIMIT } from \"../components/Dashboard\";\nimport { backupNote } from \"./RequestsMakers\";\nimport { addElementAt, arraysEqual, getCaption, removeElementAt } from \"./DashboardUtils\";\nimport { alreadyIn, mergeBothCardsOccupied } from \"./Messages\";\n\n// Function to add a note to a thread if the element is not the opened thread itself\nexport function addToWorkspace(newDashboard, element, position){\n    if(newDashboard.openedWorkspaceId===element){\n        //alreadyInAlert();\n    }\n    else{\n        newDashboard.workspaceIds = addElementAt(newDashboard.workspaceIds, position, element);\n        newDashboard.selectedNoteId = element\n    }\n}\n\n// Function to add note to the branches if a note is selected and the note is not already a child\n// Also checks that the links respect the limits. Adds the noteToAdd to the branches of noteFrom\n// and does the opposite with the roots\nexport function addToBranches (noteFrom, noteToAdd) {\n\n    const notAlreadyInBranches = !noteFrom.branches.includes(noteToAdd.id);\n    const notChildOfItself = noteFrom.id!==noteToAdd.id\n    const branchesWithinLimit = noteFrom.branches.length < LINKSLIMIT\n    const notAlreadyInRoots = !noteToAdd.roots.includes(noteFrom.id);\n    const rootsWithinLimits = noteToAdd.roots.length < LINKSLIMIT\n\n    if(notAlreadyInBranches && \n    notChildOfItself && \n    branchesWithinLimit && \n    notAlreadyInRoots && \n    rootsWithinLimits){\n\n            noteFrom.branches.push(noteToAdd.id)\n            noteToAdd.roots.push(noteFrom.id)\n            return true\n    }\n};\n\n// Specular function to remove a note from the branches and alert for all the threads\n// that rely on that connection so that the user first has to restructure them manually\nexport function removeFromBranches (newDashboard, noteFrom, noteToDel) {\n\n    // alert for all the threads that rely on the link to remove\n    for(const [, note] of newDashboard.notes){\n        for(let n=1; n<note.thread.length; n++){\n            if(note.thread[n-1]===noteFrom.id && note.thread[n]===noteToDel.id){\n                alert('The link you are tying to delete is used in the Thread : ' + getCaption(note) + '... \\nPlease restructure this Thread it if you desire to proceed.')\n                return false\n            }\n        }\n    }\n\n    // if the check is passed, remove the note from the branches of noteFrom\n    var targetIdx = noteFrom.branches.findIndex(id => id===noteToDel.id);\n    if(targetIdx!==-1){\n        noteFrom.branches = removeElementAt(\n            noteFrom.branches, \n            targetIdx\n        )\n    }\n\n    // and remove the link from the roots of noteToDel\n    targetIdx = noteToDel.roots.findIndex(id => id===noteFrom.id);\n    if(targetIdx!==-1){\n        noteToDel.roots = removeElementAt(\n            noteToDel.roots, \n            targetIdx\n        );\n    }\n\n    return true\n}\n\n// Function to force the removal of a note even if it appears in many other \n// threads or collections or branches\nexport function forceRemove(newDashboard, targetNoteId, setNotesUpdating){\n    var presenceCheck = false\n    var updatesCounter = 0\n\n    for(const [, note] of newDashboard.notes){\n\n        // remove all branches occurrences\n        if(note.branches.includes(targetNoteId)){\n            note.branches = note.branches.filter(\n                (id) => id!==targetNoteId\n            )\n            presenceCheck = true\n        }\n\n        // remove all roots occurrences\n        if(note.roots.includes(targetNoteId)){\n            note.roots = note.roots.filter(\n                (id) => id!==targetNoteId\n            )\n            presenceCheck = true\n        }\n\n        // redirect threads that relied on it and add new branches\n        if(note.thread.includes(targetNoteId)){\n            note.thread = note.thread.filter(\n                (id) => id!==targetNoteId\n            )\n            linkThreadNotes(newDashboard, note.thread, setNotesUpdating)\n            presenceCheck = true\n        }\n\n        // if any changes have been made to the current note, backup\n        if(presenceCheck){\n            updatesCounter+=1\n            setTimeout(() => {\n                backupNote(note, 'meta', setNotesUpdating)\n            }, (200 * updatesCounter))\n        }\n\n        presenceCheck = false           \n    }\n}\n\n// Link all the pairwise consecutive notes of a thread\nexport function linkThreadNotes(newDashboard, thread, setNotesUpdating){\n\n    var updatesCounter=0\n    // go through the whole thread and add the branch\n    for(let i=1; i<thread.length; i++){\n        const noteFrom = newDashboard.notes.get(thread[i-1])\n        const noteToAdd = newDashboard.notes.get(thread[i])\n\n        // if successful, backup\n        if(addToBranches(noteFrom, noteToAdd)){\n            updatesCounter+=1\n            setTimeout(() => {\n                backupNote(noteFrom, 'meta', setNotesUpdating)\n                backupNote(noteToAdd, 'meta', setNotesUpdating)\n            }, (200 * updatesCounter))\n        }\n    }\n}\n\n// Wrap an unsaved workspace with an empty note\nexport function wrapWorkspace(newDashboard, targetNoteId, setNotesUpdating, threadOrCollection){\n\n    // check that the note is empty\n    if(!newDashboard.notes.get(targetNoteId).thread.length && \n    !newDashboard.notes.get(targetNoteId).collection.length){\n\n        // check that the dragged note is not inside the collection that it is trying to wrap\n        if(!newDashboard.workspaceIds.includes(targetNoteId)){\n            const targetNote = newDashboard.notes.get(targetNoteId);\n\n            // if thread mode, add to the thread of the note and set color to yellow\n            if(threadOrCollection){\n                targetNote.thread = newDashboard.workspaceIds;\n                linkThreadNotes(newDashboard, targetNote.thread, setNotesUpdating)\n            }\n\n            // if collection mode, add to the collection of the note and set color to blue\n            else{\n                targetNote.collection = newDashboard.workspaceIds;\n            }\n\n            // set the wrapping note as the selectedNote\n            newDashboard.selectedNoteId = targetNoteId\n\n            // open the note in the workspace and backup it\n            openInWorkspace(threadOrCollection, newDashboard, setNotesUpdating, threadOrCollection)\n            backupNote(targetNote, 'meta', setNotesUpdating)\n        }\n        else{\n            alert(alreadyIn);\n        }\n    }\n}\n\n// Function to open a note in the workspace, so that the notes of the workspace \n// belong to either the notes thread or collection\nexport function openInWorkspace(workspaceMode, newDashboard, setNotesUpdating, threadOrCollection){\n\n    // close and save the workspace that is already opened\n    closeAndSaveWorkspace(true, newDashboard, setNotesUpdating, threadOrCollection);\n\n    // retrieve the note we want to open\n    const selectedNote = newDashboard.notes.get(newDashboard.selectedNoteId)\n\n    // if it is thread mode, open the thread\n    if(workspaceMode){\n        newDashboard.workspaceIds = [...selectedNote.thread]\n    }\n\n    // otherwise open the collection\n    else{\n        newDashboard.workspaceIds = [...selectedNote.collection]\n    }\n\n    // set the openedWorkspaceId as the id of the note we want to open\n    newDashboard.openedWorkspaceId = newDashboard.selectedNoteId;\n}\n\n// Function to close and save an active workspace\nexport function closeAndSaveWorkspace(leaveOpen, newDashboard, setNotesUpdating, threadOrCollection){\n\n    // If the workspace is not empty and unsaved, as for confirmation before closing it\n    if(!newDashboard.openedWorkspaceId && \n    newDashboard.workspaceIds.length && \n    !leaveOpen &&\n    !window.confirm('You have an ' + (threadOrCollection ? 'unsaved thread' : 'unsaved collection') + ', do you wish to delete it and clean the Workspace?')\n    ){\n        return\n    }\n\n    // otherwise if there is an openedWorkspaceId, save the thread or collection in there\n    else if(newDashboard.openedWorkspaceId){\n        const targetNote = newDashboard.notes.get(newDashboard.openedWorkspaceId)\n        // flag to check if any changes occurred and therefore if there needs to be backup\n        var anyChangesFlag=false\n\n        if(threadOrCollection){\n\n            anyChangesFlag = arraysEqual(targetNote.thread, newDashboard.workspaceIds)\n\n            // if changes, assign and relink\n            if(anyChangesFlag){\n                targetNote.thread = newDashboard.workspaceIds;\n                linkThreadNotes(newDashboard, targetNote.thread, setNotesUpdating)\n            }\n        }\n\n        else{\n            \n            anyChangesFlag = arraysEqual(targetNote.collection, newDashboard.workspaceIds)\n\n            if(anyChangesFlag){\n                targetNote.collection = newDashboard.workspaceIds\n            }\n        }\n\n        // if any changes, backup the note\n        if(anyChangesFlag){\n            backupNote(targetNote, 'meta', setNotesUpdating)\n        }\n\n        newDashboard.openedWorkspaceId = null;\n    }\n\n    newDashboard.workspaceIds = [];\n}\n\n// Remove old selection and select a new note\nexport function noteSelector(noteToSelect, mergeMode, setMergeMode, dashboard, setDashboard, getLinks, mergeNotes){\n\n    // If the mergeMode is not on, select a new note and update the links\n    if(!mergeMode){\n        if(!dashboard.selectedNoteId || dashboard.selectedNoteId!==noteToSelect.id){\n            // this is done to make the update efective immediately and mitigate wrong renders\n            dashboard.selectedNoteId=noteToSelect.id\n            const newDashboard = {...dashboard}\n            newDashboard.selectedNoteId = noteToSelect.id\n            getLinks(newDashboard)\n            setDashboard(newDashboard)\n        } \n    }\n\n    // otherwise, check that there are not clashes between the two mergin notes and initialise the merging process\n    else{\n        if(noteToSelect.id!==dashboard.selectedNoteId){\n            if(\n            (noteToSelect.thread.length && dashboard.notes.get(dashboard.selectedNoteId).collection.length) ||\n            (dashboard.notes.get(dashboard.selectedNoteId).thread.length && noteToSelect.collection.length)\n            ){\n                alert(mergeBothCardsOccupied)\n            }\n\n            else{\n                mergeNotes(dashboard.notes.get(dashboard.selectedNoteId), noteToSelect);\n            }\n        }\n\n        // if the user merges a note with itself, do not do anything\n        else{\n            setMergeMode(false);\n        }\n    }\n}\n\n// Function to convert thread to collection\nexport function threadToCollection(note){\n    note.collection = [...new Set([...note.thread])]\n    note.thread = []\n}\n\n// Function to convert thread to collection\nexport function collectionToThread(note){\n    note.thread = note.collection\n    note.collection = []\n}","/*\nAuthor: Nicola Mendini\nDate: 13/09/2021\nThinkyThreads Project\nDragManager function\nManages all the drag gestures between notes\n*/\n\nimport { driveBackupAuthorised, WORKSPACELIMIT } from \"../components/Dashboard\";\nimport { getWorkspace, getLinksFromProps, getSearchFromProps } from \"./DashboardPacker\";\nimport { addToWorkspace, addToBranches, removeFromBranches, wrapWorkspace, openInWorkspace } from \"./NotesManupulation\";\nimport { updateConfigFile } from \"./BackupHelper\";\nimport { backupNote } from \"./RequestsMakers\";\nimport { moveNoteInsideArea, removeElementAt } from \"./DashboardUtils\";\nimport { alertMergeMode, workspaceLimitReached } from \"./Messages\";\n\n// Manage the dragging and dropping rules\n// all the information that is needed is contained in the result\n// parameter that is provided by the DragAndDropContext component\n// from React Beautiful DnD\nexport function dragManager(\n    dashboard,\n    setDashboard, \n    mergeMode, \n    threadOrCollection, \n    setThreadOrCollection,\n    rootsOrBranches, \n    searchProps, \n    setNotesUpdating,\n    packDashboard,\n    result\n){\n\n    // if the destination is invalid do not do anything\n    if(result.destination===null){return}\n\n    // if the mergeMode is on, disable the gestures\n    else if(mergeMode){alert(alertMergeMode)}\n\n    // if the source of the dragging is the search \n    else if(result.source.droppableId==='search-area'){\n\n        // if it goes to the workspace\n        if(result.destination.droppableId==='workspace-area'){\n\n            // check that the workspace does not break the limits\n            const targetId = dashboard.search[result.source.index].id;\n            if(dashboard.workspaceIds.length > WORKSPACELIMIT){\n                alert(workspaceLimitReached)\n            }\n\n            // else if we are in thread mode, add to the thread and update the dashboard\n            else if(threadOrCollection){\n                const newDashboard = {...dashboard}\n                addToWorkspace(newDashboard, targetId, result.destination.index);\n                getLinksFromProps(newDashboard, rootsOrBranches, setNotesUpdating)\n                getWorkspace(newDashboard)\n                setDashboard(newDashboard)\n            }\n\n            // else if we are in collectionMode, check that the notes collection is not \n            // already opened in dashboard and that the note is not already in, then add it\n            // to the collection and update the dashboard\n            else{\n                if(!dashboard.openedWorkspaceId ||\n                    dashboard.openedWorkspaceId!==targetId\n                ){\n                    if(!dashboard.workspaceIds.includes(targetId)){\n                        const newDashboard = {...dashboard}\n                        newDashboard.workspaceIds.push(targetId);\n                        getWorkspace(newDashboard)\n                        setDashboard(newDashboard)\n                    }\n                }\n                else{\n                    //alreadyInAlert();\n                }\n            }\n        }\n\n        // if the destination was the links area aka branches area\n        else if(result.destination.droppableId==='branches-area'){\n            const newDashboard = {...dashboard}\n            const noteFrom = newDashboard.notes.get(dashboard.search[result.source.index].id)\n            const noteToAdd = newDashboard.notes.get(dashboard.selectedNoteId)\n            \n            // if we are in branches mode add noteTo to noteFrom\n            if(!rootsOrBranches){\n                if(addToBranches(noteToAdd, noteFrom)){\n                    backupNote(noteToAdd, 'meta', setNotesUpdating)\n                    backupNote(noteFrom, 'meta', setNotesUpdating)\n                } \n            }\n\n            // otherwise do the opposite and add noteFrom to noteTo\n            else{\n                if(addToBranches(noteFrom, noteToAdd)){\n                    backupNote(noteToAdd, 'meta', setNotesUpdating)\n                    backupNote(noteFrom, 'meta', setNotesUpdating)\n                }   \n            }\n            getLinksFromProps(newDashboard, rootsOrBranches, setNotesUpdating)\n            setDashboard(newDashboard);\n        }\n\n        // if the destination is the wrapper area\n        else if(result.destination.droppableId==='wrapper-area'){\n            const newDashboard = {...dashboard}\n            const targetNote = dashboard.search[result.source.index]\n\n            // if the current workspace has notes, wrap them with the target note\n            if(dashboard.workspaceIds.length>0){\n                wrapWorkspace(newDashboard, targetNote.id, setNotesUpdating, threadOrCollection );\n            }\n\n            // otherwise just expand the note so that the workspace now contains its thread or collection\n            else{\n                if(targetNote.thread.length){\n                    newDashboard.selectedNoteId = targetNote.id\n                    openInWorkspace(true, newDashboard, setNotesUpdating, threadOrCollection)\n                    setThreadOrCollection(true)\n                    \n                }\n                else if(targetNote.collection.length){\n                    newDashboard.selectedNoteId = targetNote.id\n                    openInWorkspace(false, newDashboard, setNotesUpdating, threadOrCollection)\n                    setThreadOrCollection(false)\n                }\n            }\n            packDashboard(newDashboard)\n        }\n\n        // if the destination is the search area itself just change the order of the notes\n        else if(result.destination.droppableId==='search-area'){\n            if(result.source.index!==result.destination.index){\n                const sourceNote = dashboard.search[result.source.index]\n                const targetNote = dashboard.search[result.destination.index]\n\n                // only if not trying to move between pinned notes\n                if(\n                !(\n                    (!targetNote.pinned && sourceNote.pinned) ||\n                    (!sourceNote.pinned && targetNote.pinned)\n                )\n                ){\n                        \n                    // reorder the notes\n                    const newDashboard = {...dashboard}\n                    newDashboard.notesOrder = moveNoteInsideArea(\n                            dashboard.notesOrder, \n                            dashboard.notesOrder.findIndex(id => id===sourceNote.id), \n                            dashboard.notesOrder.findIndex(id => id===targetNote.id)\n                    )\n\n                    // backup the new order locally and eventually on drive too\n                    window.localStorage.setItem('notes-order', JSON.stringify(newDashboard.notesOrder))\n                    if(driveBackupAuthorised){\n                        updateConfigFile(newDashboard)\n                    }\n\n                    newDashboard.selectedNoteId = sourceNote.id\n                    getLinksFromProps(newDashboard, rootsOrBranches, setNotesUpdating)\n                    getSearchFromProps(newDashboard, searchProps)\n                    setDashboard(newDashboard);\n                }\n            }\n        }\n\n        // if the destination is the search bar, open the collection of the dragging note in search\n        else if(result.destination.droppableId==='search-bar'){\n            const newDashboard = {...dashboard}\n            const targetNote = dashboard.search[result.source.index]\n            newDashboard.openedCollectionId = targetNote.id;\n            getSearchFromProps(newDashboard, searchProps)\n            setDashboard(newDashboard)\n        }\n    }\n\n    // if the source is the workspace area\n    else if(result.source.droppableId==='workspace-area'){\n\n        // if the destination is the search, remove that note from the workspace\n        // select the dragging note and update the dashboard\n        if(result.destination.droppableId==='search-area'){\n            const newDashboard = {...dashboard}\n            newDashboard.workspaceIds = removeElementAt(newDashboard.workspaceIds, result.source.index)\n            if(result.source.index>0 && threadOrCollection){\n                newDashboard.selectedNoteId = newDashboard.workspaceIds[result.source.index-1];\n                getLinksFromProps(newDashboard, rootsOrBranches, setNotesUpdating)\n            }\n            getWorkspace(newDashboard)\n            setDashboard(newDashboard)\n        }\n\n        // if the destination is the workspace area itself, just reorder the thread or collection and update\n        else if(result.destination.droppableId==='workspace-area'){\n            const newDashboard = {...dashboard}\n            newDashboard.workspaceIds = moveNoteInsideArea(newDashboard.workspaceIds, result.source.index, result.destination.index)\n            newDashboard.selectedNoteId = newDashboard.workspaceIds[result.destination.index]\n            getLinksFromProps(newDashboard, rootsOrBranches, setNotesUpdating)\n            getWorkspace(newDashboard)\n            setDashboard(newDashboard)\n        }\n    }\n\n    // if the source is the branches area\n    else if(result.source.droppableId==='branches-area'){\n\n        // if the destination is the search, remove a link\n        if(result.destination.droppableId==='search-area'){\n            const newDashboard = {...dashboard}\n            const noteFrom = newDashboard.notes.get(dashboard.links[result.source.index].id);\n            const noteToRem = newDashboard.notes.get(dashboard.selectedNoteId)\n\n            // if branches mode, remove noteToRem from noteFrom\n            if(!rootsOrBranches){\n                if(removeFromBranches(newDashboard, noteToRem, noteFrom)){\n                    backupNote(noteToRem, 'meta', setNotesUpdating)\n                    backupNote(noteFrom, 'meta', setNotesUpdating)\n                }\n            }\n\n            //otherwise do the opposite\n            else{\n                if(removeFromBranches(newDashboard, noteFrom, noteToRem)){\n                    backupNote(noteToRem, 'meta', setNotesUpdating)\n                    backupNote(noteFrom, 'meta', setNotesUpdating)\n                }\n            }\n\n            //setLinks(pack([]));\n            getLinksFromProps(newDashboard, rootsOrBranches, setNotesUpdating)\n            getSearchFromProps(newDashboard, searchProps)\n            setDashboard(newDashboard);\n        }\n\n        // if the destination is the workspace area, add to thread\n        // not a case for the collections because links are only visible in thread mode\n        else if(result.destination.droppableId==='workspace-area'){\n            if(dashboard.workspaceIds.length > WORKSPACELIMIT){\n                alert(workspaceLimitReached)\n            }\n            else{\n                const newDashboard = {...dashboard}\n                addToWorkspace(newDashboard, dashboard.links[result.source.index].id, result.destination.index);\n                getLinksFromProps(newDashboard, rootsOrBranches, setNotesUpdating)\n                getWorkspace(newDashboard)\n                setDashboard(newDashboard)\n            }\n        }\n\n        // if the destination is the branches area itself, just reorder and update\n        else if(result.destination.droppableId==='branches-area'){\n            const newDashboard = {...dashboard}\n            const targetNote = newDashboard.notes.get(newDashboard.selectedNoteId)\n            if(rootsOrBranches){\n                targetNote.roots = moveNoteInsideArea(\n                    targetNote.roots, \n                    result.source.index, \n                    result.destination.index\n                )\n            }\n            else{\n                targetNote.branches = moveNoteInsideArea(\n                    targetNote.branches, \n                    result.source.index, \n                    result.destination.index\n                )\n            }\n            backupNote(targetNote, 'meta', setNotesUpdating)\n            getLinksFromProps(newDashboard, rootsOrBranches, setNotesUpdating)\n            setDashboard(newDashboard)\n        }\n    }\n}","/*\nAuthor: Nicola Mendini\nDate: 13/09/2021\nThinkyThreads Project\nNoteDeleter function\nDeletes a note and resolves potential conflicts in the process\n*/\n\nimport { db } from \"../components/Dashboard\";\nimport { checkConflicts, removeElementAt } from \"./DashboardUtils\";\nimport { driveBackupAuthorised } from \"../components/Dashboard\";\nimport { updateConfigFile, removeNoteFile } from \"./BackupHelper\";\nimport { forceRemove } from \"./NotesManupulation\";\nimport { backupNote } from \"./RequestsMakers\";\nimport { deleteConflictAlert } from \"./Messages\";\n\n// Delete a note given by removingId from the notes array and cascade\n// forceFlag controls whether the removal shouldbe forced without asking\nexport function noteDeleter(\n    removingId, \n    forceFlag, \n    newDashboard, \n    mergeMode, \n    setMergeMode,\n    deletedNotes, \n    setDeletedNotes, \n    setNotesUpdating,\n    packDashboard\n){\n\n    // get the note to remove and check for conflicts\n    const noteToRemove = newDashboard.notes.get(removingId);\n\n    // if no conflicts\n    if(checkConflicts(newDashboard, removingId) || mergeMode){\n        \n        // remove it from the dashboard\n        newDashboard.notes.delete(removingId)\n        newDashboard.notesOrder = removeElementAt(\n            newDashboard.notesOrder, \n            newDashboard.notesOrder.findIndex(id => id===removingId)\n        )\n\n        // add its ID to the deleted notes storage\n        const newDeletedNotes = [...deletedNotes, removingId]\n        setDeletedNotes(newDeletedNotes)\n\n        // keep track of deleted note\n        newDashboard.notesEverDeleted.push(removingId)\n\n        // backup the new notes order and the new deleted notes arrays\n        window.localStorage.setItem('notes-order', JSON.stringify(newDashboard.notesOrder))\n        window.localStorage.setItem('deleted-notes', JSON.stringify(newDeletedNotes))\n        window.localStorage.setItem('notes-ever-deleted', JSON.stringify(newDashboard.notesEverDeleted))\n\n        // if this function was not called by merge mode then sanitise all collections and dashboard\n        if(!mergeMode){\n\n            // sanitise all the collections by simply removing the entry\n            // no conflicts because collections have no links\n            var updatesCounter=0\n            for(const [, note] of newDashboard.notes){\n                const removingIndex = note.collection.findIndex(id => id===removingId)\n                if(removingIndex!==-1){\n                    note.collection = removeElementAt(note.collection, removingIndex)   \n                    updatesCounter+=1\n                    setTimeout(() => {\n                        backupNote(note, 'meta', setNotesUpdating)\n                    }, (200 * updatesCounter))\n                }\n\n            }\n\n            // sanitise the dashboard\n            if(newDashboard.openedWorkspaceId===removingId){\n                newDashboard.openedWorkspaceId = null;\n            }\n            if(newDashboard.openedCollectionId===removingId){\n                newDashboard.openedCollectionId = null;\n            }\n            if(newDashboard.selectedNoteId===removingId){\n                newDashboard.selectedNoteId = null;\n            }\n        }\n\n        // if it was called by merge mode, assume it is already sanitised previously and end merge mode\n        else{\n            setMergeMode(false)\n        }\n\n        // if possible, backup the removal and update the .config file on drive\n        if(driveBackupAuthorised){\n            setNotesUpdating((prev) => prev+1)\n            removeNoteFile(noteToRemove, newDeletedNotes, setDeletedNotes, setNotesUpdating)\n            updateConfigFile(newDashboard)\n        }\n\n        // remove the note locally and update the dashboard\n        db.notes.delete(removingId)\n        packDashboard(newDashboard)\n    }\n\n    // if there are conflicts ask to force the removal through the \n    // forceRemove function\n    else{            \n        if(forceFlag || window.confirm(deleteConflictAlert)){\n            forceRemove(newDashboard, removingId, setNotesUpdating);\n            noteDeleter(\n                removingId, \n                false, \n                newDashboard,\n                mergeMode, \n                setMergeMode,\n                deletedNotes, \n                setDeletedNotes, \n                setNotesUpdating,\n                packDashboard\n            )\n        }\n    }\n}\n","/*\nAuthor: Nicola Mendini\nDate: 13/09/2021\nThinkyThreads Project\nNoteMerger function\nMerges two notes objects in a meaningful way\nUnifies all the links and concatenates the text\nFor the user doing the same manually would make the system impractical\n*/\n\nimport { LINKSLIMIT, WORKSPACELIMIT, TEXTLIMIT, db } from \"../components/Dashboard\"\nimport { setPreview } from \"./DashboardUtils\";\nimport { mergeLinksLimit, mergeTextLimit, mergeWorkspaceLimit } from \"./Messages\";\nimport { addToBranches } from \"./NotesManupulation\";\nimport { linkThreadNotes } from \"./NotesManupulation\";\nimport { backupNote } from \"./RequestsMakers\";\n\n// Merges noteA and noteB\nexport function noteMerger(\n    noteA, \n    noteB, \n    setMergeMode, \n    dashboard, \n    setNotesUpdating, \n    threadOrCollection, \n    packDashboard, \n    deleteNote\n){\n\n    // Unifies roots, branches, collection and thread by also \n    // using sets to avoid repeated entries when needed\n    const newBranches = [...new Set([...noteA.branches, ...noteB.branches])]\n    const newRoots = [...new Set([...noteA.roots, ...noteB.roots])]\n    const newCollection = [...new Set([...noteA.collection, ...noteB.collection])]\n    const newThread = [...noteA.thread, ...noteB.thread]\n\n    // check that the limits for branches and roots are met\n    if(newBranches.length > LINKSLIMIT || newRoots.length > LINKSLIMIT){\n        alert(mergeLinksLimit)\n        setMergeMode(false)\n        return\n    }\n\n    // check that the limits for thread and collections are met\n    if(newCollection.length > WORKSPACELIMIT || newThread.length > WORKSPACELIMIT){\n        alert(mergeWorkspaceLimit)\n        setMergeMode(false)\n        return\n    }\n\n    // if the checks passed, retrieve the notes and merge the contents\n    db.notes.get(noteA.id).then((dbNoteA) => \n        db.notes.get(noteB.id).then((dbNoteB) => {\n\n            const newText = dbNoteA.text + ' ' + dbNoteB.text\n\n            // check if the merged texts are still within the limits\n            // if not, abort\n            if(newText.length > TEXTLIMIT){\n                alert(mergeTextLimit)\n                setMergeMode(false)\n                return\n            }\n\n            // if all the checks passed, initialise the new note C \n            // note C takes the same id as noteA\n            const newDashboard = {...dashboard}\n            const noteC = {\n                id: noteA.id,\n                text: newText,\n                branches: newBranches,\n                roots: newRoots,\n                thread: newThread,\n                collection: newCollection,\n                pinned: noteA.pinned || noteB.pinned,\n                color: noteA.color!=='#ffffff' ? noteA.color : noteB.color,\n                colorPreview: noteA.colorPreview!=='#ffffff' ? noteA.colorPreview : noteB.colorPreview,\n                version: noteA.version\n            };\n\n            // set the preview of the noteC based on the text\n            setPreview(noteC)\n            \n            // remove occurrences of noteA and noteB in noteC to avoid circularity of reference\n            noteC.branches = noteC.branches.filter((id) => \n                id!==noteA.id && id!==noteB.id\n            );\n            noteC.roots = noteC.roots.filter((id) => \n                id!==noteA.id && id!==noteB.id\n            );\n\n            // do the same for thread and collection\n            noteC.collection = noteC.collection.filter((id) =>\n                id!==noteA.id && id!==noteB.id\n            )\n            noteC.thread = noteC.thread.filter((id) =>\n                id!==noteA.id && id!==noteB.id\n            )\n            linkThreadNotes(newDashboard, noteC.thread, setNotesUpdating)\n\n            // add noteC to the dashboard\n            newDashboard.notes.set(noteC.id, noteC);\n\n            // start cleaning all the notes that have conflicts because they relied on the id\n            // of noteB that now will not exist anymore\n            var presenceCheck = false\n            var updatesCounter=0\n\n            for(const [, note] of newDashboard.notes){\n\n                // clean from threads if noteB ID included\n                if(note.thread.includes(noteB.id)){\n                    note.thread = note.thread.flatMap(\n                        (id) => id===noteB.id ? [noteA.id] : [id]\n                    )\n                    presenceCheck = true\n                }\n\n                // clean from collections if noteB ID included\n                if(note.collection.includes(noteB.id)){\n                    if(!note.collection.includes(noteC.id)){\n                        note.collection.push(noteC.id);\n                    }\n                    note.collection = note.collection.filter(\n                        (id) => id!==noteB.id\n                    )\n                    presenceCheck = true\n                }\n                    \n                // clean from branches if noteB ID included\n                if(note.branches.includes(noteB.id)){\n                    if(!note.branches.includes(noteC.id)){\n                        addToBranches(note, noteC)\n                    }\n                    note.branches = note.branches.filter(\n                        (id) => id!==noteB.id\n                    )\n                    presenceCheck = true\n                }\n\n                // clean from roots if noteB ID included\n                if(note.roots.includes(noteB.id)){\n                    if(!note.roots.includes(noteC.id)){\n                        addToBranches(noteC, note)\n                    }\n                    note.roots = note.roots.filter(\n                        (id) => id===noteB.id\n                    )\n                    presenceCheck = true\n                }\n            \n                // if any changes have been applied, backup the note\n                if(presenceCheck){\n                    updatesCounter+=1\n                    setTimeout(() => {\n                        backupNote(note, 'meta', setNotesUpdating)\n                    }, (200 * updatesCounter))\n                }\n                \n                \n                presenceCheck = false\n            }        \n            \n            // clean the current workspace from noteB \n            if(!threadOrCollection && dashboard.workspaceIds.includes(noteA.id)){\n                newDashboard.workspaceIds = newDashboard.workspaceIds.filter((id) =>\n                    id!==noteB.id\n                )\n            }\n            else{\n                newDashboard.workspaceIds = newDashboard.workspaceIds.flatMap((id) =>\n                    id===noteB.id ? [noteA.id] : [id]\n                )\n            }\n\n            // if noteB was open inside the collection, open noteC instead\n            if(newDashboard.openedCollectionId===noteB.id){\n                newDashboard.openedCollectionId=noteC.id\n            }\n\n            // if noteB was open inside the workspace, open noteC instead\n            if(newDashboard.openedWorkspaceId===noteB.id || newDashboard.openedWorkspaceId===noteA.id){\n                newDashboard.openedWorkspaceId=noteC.id\n                newDashboard.workspaceIds = newDashboard.workspaceIds.filter(\n                    (id) => id!==noteB.id && id!==noteA.id \n                )\n            }\n\n            // select noteC, backup, delete noteB and update the dashboard\n            newDashboard.selectedNoteId = noteC.id;\n            backupNote(noteC, 'both', setNotesUpdating)\n            deleteNote(noteB.id, false, newDashboard)\n            packDashboard(newDashboard);\n        })\n    )\n}","/*\nAuthor: Nicola Mendini\nDate: 13/09/2021\nThinkyThreads Project\nDashboard component\nImplements the dashboard, which is the main component of the project\nPuts together the NotesPage, the Editor, the Settings and the \niFrame used for exporting threads as PDFs later on.\nUses lazy loading since the components that it contains are big\n*/\n\nimport { useState, useEffect, Suspense} from 'react';\nimport React from 'react'\nimport Dexie from 'dexie'\nimport { createThumbnail, getNewNote, moveNoteInsideArea} from \"../helpers/DashboardUtils\";\nimport { updateConfigFile, exportThreadGivenProps, checkDriveFolder} from '../helpers/BackupHelper';\nimport { getAllNotes } from '../helpers/DownloadHelper';\nimport { backupNote } from '../helpers/RequestsMakers';\nimport { getSearchFromProps, getLinksFromProps, getWorkspace } from '../helpers/DashboardPacker';\nimport { dragManager } from '../helpers/DragManager';\nimport { closeAndSaveWorkspace, collectionToThread, linkThreadNotes, noteSelector, threadToCollection } from '../helpers/NotesManupulation';\nimport { noteDeleter } from '../helpers/NoteDeleter';\nimport { noteMerger } from '../helpers/NoteMerger';\nimport { cleanWorkspace } from '../helpers/Messages';\nimport { suspenseLoader } from '../helpers/DashboardUtils';\n//importing and registering the formula compiler\nimport \"katex/dist/katex.min.css\";\nimport katex from \"katex\";\n\nwindow.katex = katex;\n\n// Define the lazy loading\nconst NoteEditor = React.lazy(() => import(\"./Editor\"));\nconst Settings = React.lazy(() => import(\"./Settings\"));\nconst NotesPage = React.lazy(() => import('./NotesPage'));\n\n// Define the limits of the app to avoid extreme usages and crashes\nexport const LINKSLIMIT = 150\nexport const WORKSPACELIMIT = 300\nexport const TEXTLIMIT = 1048576\nexport const PREVIEWLIMIT = 200\n\n// Define some shared variables that will be accessible from all components\nexport var driveBackupAuthorised = false\nexport var shareDriveFolderId = ''\nexport var shareConfigFile = {id: ''}\n\n// Initialise the local indexedDB that will contain the notes\nexport const db = new Dexie('notes-db')\ndb.version(1).stores({\n    notes: \n        'id, text, preview, branches, roots, thread, collection' + \n        ', pinned, color, colorPreview, attachedImg, version'\n})\n\n// Dashboard component, \n// takes the Google sign in and out functions\n// a GAPIloaded flag to know when the GoogleAPI script has been loaded\n// and the current user to make sure that the user has logged in\n// the username di per se is not used\nconst Dashboard = ({\n    signInFunction, \n    signOutFunction, \n    GAPIloaded, \n    currentUser\n}) => {\n\n    // Main state of the dashboard containing all the correlated variables\n    // they are put together to minimise the number of renderings and \n    // avoid clashes due to asynchronous state updating\n\tconst [dashboard, setDashboard] = useState(\n        {\n            notes: new Map(), \n            notesOrder: [],\n            notesEverDeleted: [],\n            workspaceIds: [],\n            selectedNoteId: null,\n            openedCollectionId: null,\n            openedWorkspaceId: null,\n            search: [],\n            links: [],\n            workspace: [],\n            checkedAgainstDrive: true\n        }\n    );\n\n    // State that defines the search, in particular\n    // the text in the search bar and the state of the two buttons on it\n    const [searchProps, setSearchProps] = useState({\n        searchText:'', \n        threadFilter: false, \n        collectionFilter: false,\n        colorFilter: '#ededed'\n    })\n\n    // State containing the deleted notes, used to remove them from drive \n    // in a second moment if there are internet interruptions\n    const [deletedNotes, setDeletedNotes] = useState([]);\n    // State that defines whether the user wants to see Roots or Branches\n    const [rootsOrBranches, setRootsOrBranches] = useState(false);\n    // State that defines the workspace mode currently on\n    const [threadOrCollection, setThreadOrCollection] = useState(false);\n    // State that defines whereas the mergemode is on\n    const [mergeMode, setMergeMode] = useState(false);\n    // State that defines the page of the dashboard, whether notes, \n    // editor or settings\n    const [currentPage, setCurrentPage] = useState('notes');\n    // State that defines the current ID of the thinkythreads folder on drive\n    const [driveFolderId, setDriveFolderId] = useState(null);\n    // Darkmode flag\n    const [darkMode, setDarkMode] = useState(false);\n    // State tha keeps the count of how many notes are updating at the moment\n    const [notesUpdating, setNotesUpdating] = useState(0)\n\n    // Effect called only when the component is first loaded\n    // Retrieves the notes, notesOrder and deletedNotes from the db\n    useEffect(() => {\n        const newDashboard = {...dashboard}\n        db.notes.toArray().then(function(resp){\n            resp.forEach((note) => {\n                newDashboard.notes.set(note.id, note)\n                createThumbnail(note)\n            })\n\n            const notesOrder = JSON.parse(window.localStorage.getItem('notes-order'))\n            const deletedNotes = JSON.parse(window.localStorage.getItem('deleted-notes'))\n            const notesEverDeleted = JSON.parse(window.localStorage.getItem('notes-ever-deleted'))\n\n            if(notesOrder){\n                newDashboard.notesOrder = notesOrder\n            }\n            else{\n                newDashboard.notesOrder = [...newDashboard.notes.keys()]\n            }\n            if(deletedNotes){\n                setDeletedNotes(deletedNotes)\n            }\n            if(notesEverDeleted){\n                newDashboard.notesEverDeleted = notesEverDeleted\n            }\n            packDashboard(newDashboard)\n        })\n\n        const darkModeStored = window.localStorage.getItem('dark-mode')\n        if(darkModeStored){\n            setDarkMode(darkModeStored==='true')\n        }\n    // eslint-disable-next-line\n    },[])\n\n    // Effect that is called every time the rootsOrBranches switch changes\n    // Refreshed the Links area of the dashboard\n    useEffect(() => {\n        const newDashboard = {...dashboard}\n        getLinks(newDashboard)\n        setDashboard(newDashboard)\n    // eslint-disable-next-line\n\t}, [rootsOrBranches]);\n\n    // Effect that is called every time the searchProps change\n    // Refreshed the Search area of the dashboard\n    useEffect(() => {\n        const newDashboard = {...dashboard}\n        getSearch(newDashboard)\n        setDashboard(newDashboard)\n    // eslint-disable-next-line\n\t}, [searchProps]);\n\n    // Effect that kicks in when either GAPIloaded\n    // or currentUser change\n    // Accesses the user's Drive and checks for the existence of\n    // a thinkythreads folder\n    useEffect(() => {\n        driveBackupAuthorised = false\n        if(GAPIloaded && currentUser){\n            driveBackupAuthorised = true\n            checkDriveFolder(setDriveFolderId);\n        }\n    // eslint-disable-next-line\n    },[GAPIloaded, currentUser])\n\n\n    // Once the folder is found or created, this effect retrieves all notes from drive\n    useEffect(() => {\n        shareDriveFolderId = driveFolderId\n        if(GAPIloaded && currentUser && driveFolderId){\n            synchNotes()\n        }\n    // eslint-disable-next-line\n    },[driveFolderId, GAPIloaded, currentUser])\n\n    const synchNotes = () => {\n        if(dashboard.checkedAgainstDrive){\n            console.log('synching')\n            dashboard.checkedAgainstDrive = false\n            getAllNotes(\n                {...dashboard}, \n                deletedNotes, \n                setDeletedNotes, \n                setNotesUpdating, \n                packDashboard\n            )\n        }\n    }\n\n    // Utils function used to backup a note\n    // takes the note itself and a metaOrMedia\n    // flag that controls whether there should be a partial or full backup\n    // eg: links, colour, pinned, etc (meta) or/and main body text (media)\n    const backup = async (note, metaOrMedia) => {\n        backupNote(note, metaOrMedia, setNotesUpdating)\n    }\n\n    // Utils function used to refresh the whole dashboard and not just individual areas\n    const packDashboard = async (newDashboard) => {\n        getSearch(newDashboard)\n        getLinks(newDashboard)\n        getWorkspace(newDashboard)\n        setDashboard(newDashboard)\n    }\n\n    // Change the notes appearing on the Search area based on the current search props\n    const getSearch = async (newDashboard) => {\n        getSearchFromProps(newDashboard, searchProps)\n\t}\n\n    // Change the notes appearing in the Links area based on the rootsOrBranches flag\n    const getLinks = async (newDashboard) => {\n        getLinksFromProps(newDashboard, rootsOrBranches, setNotesUpdating)\n    }\n\n    // Add a new note to the notes hashmap and put it first in the Search Order\n\tconst addNote = async () => {\n\n        const newDashboard = {...dashboard}\n        const newNote = getNewNote()\n\n        // Putting the note first in the order\n        newDashboard.notesOrder = [newNote.id, ...newDashboard.notesOrder]\n\n        // Backing up the notes order locally\n        window.localStorage.setItem('notes-order', JSON.stringify(newDashboard.notesOrder))\n\n        // Adding the new note to the HashMap and selecting it\n        newDashboard.notes.set(newNote.id, newNote)\n        newDashboard.selectedNoteId = newNote.id\n\n        // If the note is added when a collection is open, add it to that collection \n        // And backup the meta of the note that contains the collection\n        if(newDashboard.openedCollectionId){\n            const collectionNote = newDashboard.notes.get(newDashboard.openedCollectionId)\n            collectionNote.collection.push(newNote.id)\n            backup(collectionNote, 'meta')\n        }\n\n        // Backup the new note and the notes order\n        db.notes.put(newNote)\n        backup(newNote, 'meta')\n        if(driveBackupAuthorised){\n            updateConfigFile(newDashboard)\n        }\n\n        // Update the dashboard and open the editor component\n\t\tpackDashboard(newDashboard)\n        setCurrentPage('editor')\n\t}\n\n    // Update a note after the editor is closed\n    const updateNote = async (newSelectedNote, action, moveToEndFlag) => {\n\n        // If the action selected from the editor was to get all the occurences,\n        // open them in the workspace\n        const newDashboard = {...dashboard}\n        if(action==='get-occurrences'){\n            openOccurrences(newDashboard)\n        }\n\n        // Backup and update the dashboard such that it contains the updated note\n        newDashboard.notes.set(newSelectedNote.id, newSelectedNote);\n        newDashboard.selectedNoteId = newSelectedNote.id\n\n        if(moveToEndFlag){\n            moveToTheEnd(newSelectedNote, newDashboard)\n        }\n        backup(newSelectedNote, 'both')\n        packDashboard(newDashboard);\n    }\n\n    // Delete a note by calling the note deleter function\n    const deleteNote = async (removingId, forceFlag, newDashboard) => {\n\n        // If no newDashboard is given, use the one from the state\n        // used because sometimes many operations have to happen on the same\n        // dashboard before the UI update is called, improves efficiency\n        if(!newDashboard){\n            newDashboard = {...dashboard}\n        }\n\n        noteDeleter(\n            removingId, \n            forceFlag, \n            newDashboard, \n            mergeMode, \n            setMergeMode,\n            deletedNotes, \n            setDeletedNotes, \n            setNotesUpdating,\n            packDashboard\n        )\n\n        // If the mergeMode was true, set it to false\n        // This happens when the merging procedure is called\n        if(mergeMode){\n            setMergeMode(false)\n        }\n    }\n\n    // Function that manges all the dragging gestures between notes of the UI\n    const handleOnDragEnd = async (result) => {\n        dragManager(\n            dashboard, \n            setDashboard, \n            mergeMode, \n            threadOrCollection, \n            setThreadOrCollection,\n            rootsOrBranches, \n            searchProps, \n            setNotesUpdating,\n            packDashboard,\n            result\n        )\n    }\n\n    // Function that changes the mode of the dashboard\n    // but it has to be unwrapped otherwise show an alert\n    // if its unwrapped it switched by converting the workspace\n    // to get rid of repeated notes for collections\n    const threadOrCollectionManage = async () => {\n        if(dashboard.openedWorkspaceId){\n            alert(cleanWorkspace)\n        }\n        else{\n            if(threadOrCollection){\n                const newDashboard = {...dashboard}\n                newDashboard.workspaceIds = [...new Set([...newDashboard.workspaceIds])]\n                getWorkspace(newDashboard)\n                setDashboard(newDashboard)\n                setThreadOrCollection(false)\n            }\n            else{\n                setThreadOrCollection(true)\n            }\n        }\n    }\n\n    // Function that calls the noteSelector\n    // called when a note is selected (click on)\n    const selectNote = async (noteToSelect) => {\n        noteSelector(\n            noteToSelect, \n            mergeMode, \n            setMergeMode, \n            dashboard, \n            setDashboard, \n            getLinks, \n            mergeNotes\n        )\n    }   \n\n    // Function that calls the noteMerger when a note is selected in mergeMode on\n    const mergeNotes = async (noteA, noteB) => {\n        noteMerger(\n            noteA, \n            noteB, \n            setMergeMode, \n            dashboard, \n            setNotesUpdating, \n            threadOrCollection, \n            packDashboard, \n            deleteNote\n        )\n    }\n\n    // Function that closes the workspace and eventually saves it inside a note\n    // Takes a leaveOpen flag that does not update the dashboard if true\n    // used to perform multiple operations on the same dashboard before UI can update\n    const closeAndSave = async (leaveOpen, newDashboard) => {\n        if(!newDashboard){\n            newDashboard={...dashboard}\n        }\n\n        closeAndSaveWorkspace(\n            leaveOpen, \n            newDashboard, \n            setNotesUpdating, \n            threadOrCollection\n        )\n\n        if(!leaveOpen){\n            packDashboard(newDashboard)\n        }\n    }\n\n    // Function that opens the occurences of a note among all the other notes\n    const openOccurrences = async (newDashboard) => {\n\n        closeAndSave(true, newDashboard);\n\n        // applies a filter that checks if the current note is either in a thread or \n        // collection of any other note\n        newDashboard.workspaceIds = dashboard.notesOrder.filter(\n            (id) => \n                dashboard.notes.get(id).thread.includes(dashboard.selectedNoteId) ||\n                dashboard.notes.get(id).collection.includes(dashboard.selectedNoteId)\n        )\n\n        // Set workspace mode to false (collection mode)\n        setThreadOrCollection(false);\n    }\n\n    // Utils function that exports the thread as PDF or to print\n    const exportThread = async () => {\n        exportThreadGivenProps(dashboard)\n    }\n\n    // Utils function that opens the editor by first retrieving the \n    // note from the local indexedDB because the text is not stored \n    // on the RAM for efficiency \n    const openEditor = async () => {\n        db.notes.get(dashboard.selectedNoteId).then((dbNote) => {\n            dashboard.notes.set(dashboard.selectedNoteId, dbNote)\n            setCurrentPage('editor');\n        })\n    }\n    \n    // Function that closes the opened collection of the Search area\n    const closeCollection = async () => {\n        const newDashboard = {...dashboard}\n        newDashboard.openedCollectionId = null\n        getSearch(newDashboard)\n        setDashboard(newDashboard)\n    }\n\n    // swap between thread or collection\n    const threadCollectionSwap = (threadCollectionFlag) => {\n\n        const newDashboard = {...dashboard}\n        const selectedNote = newDashboard.notes.get(newDashboard.selectedNoteId)\n        if(threadCollectionFlag){\n            threadToCollection(selectedNote)\n        }\n        else{\n            collectionToThread(selectedNote)\n            linkThreadNotes(newDashboard, selectedNote.thread, setNotesUpdating)\n            if(newDashboard.openedCollectionId===newDashboard.selectedNoteId){\n                newDashboard.openedCollectionId=null\n            }\n        }\n        if(newDashboard.openedWorkspaceId===newDashboard.selectedNoteId){\n            setThreadOrCollection(!threadOrCollection)\n        }\n        packDashboard(newDashboard)\n        backup(selectedNote, 'meta')\n        setCurrentPage('notes')\n    }\n\n    // Function to move a note all the way to the end of the search\n    const moveToTheEnd = (note, newDashboard) => {\n\n        var performUpdate = false\n        if(!newDashboard){\n            performUpdate = true\n            newDashboard = {...dashboard}\n        }\n        newDashboard.notesOrder = moveNoteInsideArea(\n            newDashboard.notesOrder,\n            newDashboard.notesOrder.findIndex(id => id===note.id),\n            newDashboard.notesOrder.length-1\n        )\n        if(performUpdate){\n            getSearchFromProps(newDashboard, searchProps)\n            setDashboard(newDashboard)\n        }\n    }\n\n\treturn (\n        <div>\n\n            {currentPage==='notes' && \n                <Suspense fallback={suspenseLoader}>\n                    <NotesPage \n                        darkMode={darkMode}\n                        dashboard={dashboard}\n                        handleOnDragEnd={handleOnDragEnd}\n                        GAPIloaded={GAPIloaded}\n                        currentUser={currentUser}\n                        setCurrentPage={setCurrentPage}\n                        notesUpdating={notesUpdating}\n                        setDarkMode={setDarkMode}\n                        closeCollection={closeCollection}\n                        addNote={addNote}\n                        selectNote={selectNote}\n                        mergeMode={mergeMode}\n                        setMergeMode={setMergeMode}\n                        openEditor={openEditor}\n                        rootsOrBranches={rootsOrBranches}\n                        closeAndSave={closeAndSave}\n                        threadOrCollection={threadOrCollection}\n                        threadOrCollectionManage={threadOrCollectionManage}\n                        setRootsOrBranches={setRootsOrBranches}\n                        searchProps={searchProps}\n                        setSearchProps={setSearchProps}\n                        synchNotes={synchNotes}\n                    />\n                </Suspense>\n                \n            }\n\n            {currentPage==='editor' && dashboard.selectedNoteId && \n\n                <Suspense fallback={suspenseLoader}>\n                    <NoteEditor \n                        setCurrentPage={setCurrentPage} \n                        selectedNote={dashboard.notes.get(dashboard.selectedNoteId)} \n                        updateNote={updateNote}\n                        deleteNote={deleteNote}\n                        darkMode={darkMode}\n                        exportThread={exportThread}\n                        threadCollectionSwap={threadCollectionSwap}\n                        moveToTheEnd={moveToTheEnd}\n                    />\n                </Suspense>\n            }\n\n            <iframe title='printer' id=\"ifmcontentstoprint\" style={\n                {\n                    height: '0px', \n                    width: '0px', \n                    position: 'absolute', \n                    border: '0'\n                    }\n                }>\n            </iframe>\n\n            {currentPage==='settings' && \n\n                <Suspense fallback={suspenseLoader}>\n                    <Settings \n                        setCurrentPage={setCurrentPage} \n                        signInFunction={signInFunction} \n                        signOutFunction={signOutFunction} \n                        loadedUser={currentUser} \n                        GAPIloaded={GAPIloaded}/>\n                </Suspense>\n            }\n\n        </div>\n\t);\n};\n\nexport default Dashboard;\n","/*\nAuthor: Nicola Mendini\nDate: 13/09/2021\nThinkyThreads Project\nDashboardUtils function\nUtils functions to perform small operations\n*/\n\nimport { nanoid } from \"nanoid\";\nimport { PREVIEWLIMIT } from \"../components/Dashboard\";\nimport Loader from 'react-loader-spinner';\nimport React from 'react'\n\nconst truncate = require('truncate-html')\n\n// Adds element at a certain position\nexport function addElementAt (sequence, position, element) {\n    return [...sequence.slice(0, position), element, ...sequence.slice(position)]\n}\n\n// Removes the element at a given position\nexport function removeElementAt (sequence, position) {\n    return [...sequence.slice(0, position), ...sequence.slice(position+1)];\n}\n\n// Moves a note within an area\nexport function moveNoteInsideArea (area, originalIndex, targetIndex) {\n    var newArea = removeElementAt(area, originalIndex)\n    const note = area[originalIndex];\n    newArea = [...newArea.slice(0, targetIndex), note, ...newArea.slice(targetIndex)]\n    return newArea;\n}\n\n// Truncates a string with three dots\nexport function truncString (string, n){\n    return string.substr(0,n-1)+(string.length>n?'...':'');\n};\n\n// Gets a caption from a notes preview\nexport function getCaption(targetNote){\n    const newPreview = targetNote.preview.replace('<br/>', '<br>')\n    return truncString(newPreview.split('<br>')[0].replace(/<[^>]*>?/gm, ''), 100)\n}\n\n// Check if the note defined by idx has any conflict with any other note\nexport function checkConflicts (newDashboard, checkingId) {\n    const reducer = (cumulativeClause, id) => \n        cumulativeClause && \n        !newDashboard.notes.get(id).thread.includes(checkingId) && \n        !newDashboard.notes.get(id).branches.includes(checkingId);\n    const noConflictsFlag = newDashboard.notesOrder.reduce(reducer, true);\n    return noConflictsFlag;\n}\n\n// Copy note with a fresh ui_id so that it can be used as draggable\nexport function copyNote (note) {\n    return {\n        ui_id: nanoid(),\n        id: note.id,\n        text: note.text,\n        preview: note.preview,\n        branches: note.branches,\n        roots: note.roots,\n        thread: note.thread,\n        collection: note.collection,\n        pinned: note.pinned,\n        color: note.color,\n        colorPreview: note.colorPreview,\n        attachedImg: note.attachedImg\n    };\n}\n\n// If the note has an image at the first position, it \n// replaces the text with the image so that it can be used as a preview\n// just an efficiency trick\nexport function createThumbnail(note){\n    if(note.attachedImg.length){\n        const [imgStart, imgEnd, isFirst] = note.attachedImg\n        if(isFirst && note.text.length > imgEnd-imgStart){\n            note.text = note.text.substring(imgStart, imgEnd).split('\"')[0]\n        }\n    }\n    else{\n        delete note.text\n    }\n}\n\n// Get a fresh note with new ID\nexport function getNewNote(){\n    const newNote = {\n        id: nanoid(),\n        text: '',\n        preview: '',\n        branches: [],\n        roots: [],\n        thread: [],\n        collection: [],\n        pinned: false,\n        color: '#ffffff',\n        colorPreview: '#ffffff',\n        attachedImg: false,\n        version: 0\n    }\n    return newNote\n}\n\n// Set the preview of a note based on the note itself\nexport function setPreview(note){\n\n    // regular expression to check whether the note contains an image\n    const re = /<img src=.*?>/gm\n    const img = re.exec(note.text)\n\n    // if so, set the note.attachedImg attribute with info about the position of the img in the html \n    if(img){\n        const isFirst = note.text.substring(0, img.index).replace( /(<([^>]+)>)|(\\s|(&nbsp))*/gm, '')===''\n        note.attachedImg = [img.index+10, img.index+img[0].length, isFirst]\n    }\n    else{\n        note.attachedImg = false\n    }\n\n    // remove all spaces to compute the preview\n    var preview = truncate.default(\n            note.text.replace(/<p><br\\/><\\/p>|<p>(\\s|(&nbsp))*<\\/p>|<img .*?>/gm,''), \n            PREVIEWLIMIT,\n            {ellipsis: '...'}\n        )\n\n    // if the preview is empty\n    if(preview.replace( /(<([^>]+)>)/ig, '')===''){\n\n        // if there is an image\n        if(note.attachedImg){\n            preview = 'image only note'\n        }\n\n        // if the preview is empty and the note has no images either\n        else{\n            preview = 'empty note kept for its links'\n        }\n    }\n    note.preview = preview\n}\n\n// Tiny suspense loader component to avoid blank loading pages\nexport const suspenseLoader = (\n    <div style={{\n        justifyContent: 'center', \n        display: 'flex'\n        }}\n    >\n        <Loader\n            type=\"ThreeDots\"\n            color=\"#c6c6c6\"\n            height={50}\n            width={50}\n            style={{\n                marginTop: '25%'\n            }}\n        />\n    </div>\n)\n\n// Utils function to see if two arrays are equal in a shallow way\nexport function arraysEqual(array1, array2){\n    var areDifferent = false\n    // if length is different, changes are sure\n    if(array1.length!==array2.length){\n        areDifferent=true\n    }\n\n    // otherwise check element by element\n    else{\n        for(let i=0; i<array1.length; i++){\n            if(array1[i]!==array2[i]){\n                areDifferent=true\n            }\n        }\n    }\n    return areDifferent\n}\n\n\n","export const alreadyIn = 'cannot insert a note inside its own Thread or Collection'\nexport const cleanWorkspace = 'Please close your workspace before changing between Thread Mode and Collection Mode.'\nexport const charLimit = 'Character limit reached. Additional content will not be saved. Please start a new note instead.'\nexport const mergeModeOn = 'Merge Mode is on, please select another card to merge to the pink card. The content, links and references of the card you select will be copied. If you want to exit it, press the button again.'\nexport const driveNotConnected = 'Google Drive is not connected. Please Login from the Settings page to allow the backup.'\nexport const newNoteDelimiter = '------------------------------------------------------------ new note ---------------------------------------------------'\nexport const exportBeginDelimiter = '--------------------------------------------------------- exported thread -------------------------------------------\\n'\nexport const alertMergeMode = 'Merge Mode is on. Please finish merging or exit the Merge Mode before doing anything else.'\nexport const workspaceLimitReached = 'Workspace length limit reached. Please save and start a new Workspace instead.'\nexport const deleteConflictAlert = 'The note you want to delete compares in the branches of other notes. If you proceed, the system will automatically redirect the links of the other notes to preserve the connectivity. Otherwise, please restructure your links manually until this alert disappears.'\nexport const mergeLinksLimit = 'The number of links of the resulting note would exceed the limit. Please remove some links to continue.'\nexport const mergeWorkspaceLimit = 'The size of the Thread or Collection of the resulting note would exceed the limit. Please remove some notes manually to continue.'\nexport const mergeTextLimit = 'The size of the resulting text exceeds the limit. Please shorten some text to continue.'\nexport const mergeBothCardsOccupied = 'Both the cards contain a Thread or a Collection and this generates a conflict in the mergin process. Please empty the Thread or Collection of one of the two notes and try again.'"],"sourceRoot":""}